{"title": "async/await - What You Should Know", "content": "<h2>Introduction</h2>\n<p>Sometimes, we use new technologies while we are not aware of the bottlenecks and weird parts of that technology which eventually might trap us in bad situations like deadlocks which may be really hard to track. What exactly happens in Task-based Asynchronous Pattern (TAP), what\u00a0are the improvements since .NET 4.0, how may we introduce a deadlock and how to prevent it?</p>\n<p>Consider somewhere in your code, you need to do something asynchronous, what are the different ways to do it? Here are some of the patterns:</p>\n<ul>\n<li>Asynchronous Programming Model (APM): This model is also called\u00a0<code>IAsyncResult</code>\u00a0pattern where asynchronous operations require\u00a0<code>Begin</code>\u00a0and\u00a0<code>End</code>\u00a0methods. You are responsible to call\u00a0<code>Begin</code>\u00a0method of that operation and somewhere else pool for the completion/cancellation status and finally call\u00a0<code>End</code>method to retrieve the actual result of that operation. It is possible to define a callback function so when the operation is done, your callback function is called or you can block your execution until the result is ready. This pattern is not recommended in the new development, please keep it in mind.</li>\n<li>Event-based Asynchronous Pattern (EAP): This type of async programming was introduced in .NET 2.0 and is not recommended in the new development. In this model, you need to have event handler delegate types and\u00a0<code>EventArg</code>-derived types and in some scenarios, a worker thread to handle the async job and when it is finished, signal the parent about completion of the job.</li>\n<li>TAP model: We will discuss it in this article.</li>\n</ul>\n<p>In the above patterns, you may easily end-up with lots of worker threads that are consuming your resources or in the worse case, you may face\u00a0a hard time to manage sequence of events and execution process.</p>\n<p>But, what about a way to somehow code synchronous but execute it asynchronous? Just leave the hard part to the compiler to make it happen for us?</p>\n<h2>async/await</h2>\n<h3>What Does async/await Exactly Do?</h3>\n<p>Whenever you declare or see a function as\u00a0<code>async</code>, it means that this function is wait able and you can call it asynchronously using\u00a0<code>await</code><strong>\u00a0</strong>keyword. As soon as compiler sees the\u00a0<code>await</code>\u00a0keyword, it does the magic for us and immediately returns to the calling function without the need to wait for the job to be completed and the execution would be able to continue its job.</p>\n<p>It sounds great, isn\u2019t it?</p>\n<p><img class=\"alignnone size-full wp-image-1128\" src=\"https://emolike.net/wp-content/uploads/2018/11/async1.png\" width=\"785\" height=\"605\" alt=\"\" srcset=\"https://emolike.net/wp-content/uploads/2018/11/async1.png 785w, https://emolike.net/wp-content/uploads/2018/11/async1-300x231.png 300w, https://emolike.net/wp-content/uploads/2018/11/async1-768x592.png 768w, https://emolike.net/wp-content/uploads/2018/11/async1-350x270.png 350w\" sizes=\"(max-width: 785px) 100vw, 785px\" /></p>\n<p>Here is the explanation:</p>\n<ol>\n<li>The\u00a0<code>doTheJob()</code>\u00a0is called (this is our initial step).</li>\n<li>The function executes synchronously until it reaches the\u00a0<code>await</code>\u00a0keyword in\u00a0<code>doSomethingASync()</code>\u00a0where the asynchronous task is returned.</li>\n<li>A new\u00a0<code>Task</code>\u00a0is created on-the-fly and starts to execute asynchronously and the continuation is scheduled at this point to run the remainder of the code in\u00a0<code>doTheJob()</code>.</li>\n<li>The execution continues in the \u201canounymous-task\u201d function until it reaches to \u201c<code>return</code>\u201d and continues in the \u201c<code>doTheJob()</code>\u201d synchronously up to \u201c<code>return</code>\u201d.</li>\n<li>The execution of this function is done too and the\u00a0<code>Task</code>\u00a0which is returned by\u00a0<code>doTheJob()</code>\u00a0is completed and any possible continuations registered with it may now be scheduled.</li>\n</ol>\n<p>It seems a little weird but it is actually simple to understand. as you may have already noticed, although your code seems to be very similar to synchronous programming, but in fact it is going to be executed in an\u00a0<code>async</code>way. You can simply await for a \u201ctime consuming\u201d task and leave it there to be completed and schedule your execution once it is done!</p>\n<h3>What is the Benefit?</h3>\n<ul>\n<li>Your synchronous style of coding would be executed asynchronously , that\u2019s the magic (of course with the help of\u00a0<code>async</code>/<code>await</code>\u00a0and\u00a0<code>Task.Run</code>\u00a0in this article for example)</li>\n<li>You won\u2019t be worried anymore about lots of event pooling/checking, thread synchronizations and tough situations you experienced before just to handle multi-threaded asynchronous approaches.<br />\nOf course, you still have to understand asynchronous programming and how to synchronous any shared state, which means there\u2019s still the potential for race conditions, deadlocks, starvation, etc. as you may find in this article. (See the \u201cWhat is the\u00a0<code>ConfigureAwait()</code>\u00a0for\u201d)</li>\n<li>Your code is more readable, understandable and thus debug able.</li>\n</ul>\n<h3>What is the Difference with ContinueWith() in .NET 4.0?</h3>\n<p>Actually, the\u00a0<code>async</code>/<code>await</code>\u00a0is a replacement of their successor \u201c<code>ContinueWith()</code>\u201d which was introduced in NET 4.0. Each approach has its pros and cons.</p>\n<ul>\n<li><code>ContinueWith</code>\u00a0is ignorance of sync context</li>\n<li><code>ContinueWith</code>\u00a0pushes you to a new thread, even if the parent is already complete</li>\n<li>Access\u00a0<code>.Result</code>\u00a0on a faulted\u00a0<code>Task</code>\u00a0inside of\u00a0<code>ContinueWith</code>\u00a0will re-throw</li>\n<li><code>Async</code>/<code>await</code>\u00a0will try to keep you on the same thread if they can</li>\n</ul>\n<p>So upgrade to .NET 4.5 and use\u00a0<code>async</code>\u00a0and\u00a0<code>await</code>\u2026</p>\n<h3>What is the ConfigureAwait() for?</h3>\n<p>It was introduced since .NET 4.5 because of some deadlock situation which may happen in accordance\u00a0with a bad code structure. Consider the following diagram:</p>\n<p><img class=\"alignnone size-full wp-image-1129\" src=\"https://emolike.net/wp-content/uploads/2018/11/async2.png\" width=\"648\" height=\"542\" alt=\"\" srcset=\"https://emolike.net/wp-content/uploads/2018/11/async2.png 648w, https://emolike.net/wp-content/uploads/2018/11/async2-300x251.png 300w, https://emolike.net/wp-content/uploads/2018/11/async2-323x270.png 323w\" sizes=\"(max-width: 648px) 100vw, 648px\" /></p>\n<p>What happened? Did you get it?</p>\n<ol>\n<li>When you awaitened in\u00a0<code>Fn2()</code>, it actually moved the\u00a0<code>f()</code>\u00a0execution into another context with its thread pool and the rest of\u00a0<code>Fn2()</code>\u00a0was wrapped to be executed after the\u00a0<code>f()</code>\u00a0call is done.</li>\n<li>The execution control returned to\u00a0<code>Fn1()</code>\u00a0and continued until it reached out to a\u00a0<strong>Blocking</strong>\u00a0wait. Here is the point. (<em>You actually blocked \u201cContext a\u201d execution process for another async operation to be completed)</em></li>\n<li>As soon as\u00a0<code>async</code>\u00a0operation in \u201c<code>Context b</code>\u201d is completed, it tries to get access to \u201c<code>Context a</code>\u201d just to inform it that \u201cexecution is done, let\u2019s continue with the wrapped part\u201d.</li>\n<li>But, \u201c<code>Context a</code>\u201d is blocked before!</li>\n<li>Deadlock!</li>\n</ol>\n<p>There are two approaches for that:</p>\n<ul>\n<li>Never use any kind of blocking waits and instead use\u00a0<code>WhenAll</code>\u00a0or\u00a0<code>When</code><strong>\u00a0</strong>functions to wait for a task to be completed and continue after completion.</li>\n<li>Allow\u00a0<u>wrapped content</u>\u00a0to be executed in \u201c<code>Context b</code>\u201c.</li>\n</ul>\n<p>For the second approach, you need to somehow configure the\u00a0<code>await</code><strong>\u00a0</strong>keyword to be aware of that! So you need to call\u00a0<code>ConfigureAwait(false)</code>\u00a0so the compiler would know that the wrapped content must be executed in the\u00a0<code>async</code>\u00a0context and there is no need to return back to calling context just to continue wrapped content!</p>\n<p>continue reading in Codeproject :</p>\n<p><a href=\"https://www.codeproject.com/Articles/1054993/async-await-What-You-Should-Know-Updated\">https://www.codeproject.com/Articles/1054993/async-await-What-You-Should-Know-Updated</a></p>\n", "slug": "async-await-what-you-should-know", "date": 1543240696, "cats": [0, 13, 14, 17, 15]}