{"title": "Entity Framework, ToList vs AsEnumerable vs AsQueryable", "content": "<h3><strong>ToList()</strong></h3>\n<ul>\n<li>Execute the query immediately</li>\n</ul>\n<h3><strong>AsEnumerable()</strong></h3>\n<ul>\n<li>lazy (execute the query later)</li>\n<li>Parameter:\u00a0<code>Func&amp;lt;TSource, bool&amp;gt;</code></li>\n<li>Load\u00a0<strong>EVERY</strong>\u00a0record into application memory, and then handle/filter them. (e.g. Where/Take/Skip, it will select * from table1, into the memory, then select the first X elements) (In this case, what it did: Linq-to-SQL + Linq-to-Object)</li>\n</ul>\n<h3><strong>AsQueryable()</strong></h3>\n<ul>\n<li>lazy (execute the query later)</li>\n<li>Parameter:\u00a0<code>Expression&amp;lt;Func&amp;lt;TSource, bool&amp;gt;&amp;gt;</code></li>\n<li>Convert Expression into T-SQL (with the specific provider), query remotely and load result to your application memory.</li>\n<li>That\u2019s why DbSet (in Entity Framework) also inherits IQueryable to get the efficient query.</li>\n<li>Do not load every record, e.g. if Take(5), it will generate select top 5 * SQL in the background. This means this type is more friendly to SQL Database, and that is why this type usually has higher performance and is recommended when dealing with a database.</li>\n<li>So\u00a0<code>AsQueryable()</code>\u00a0usually works much faster than\u00a0<code>AsEnumerable()</code>\u00a0as it generate T-SQL at first, which includes all your where conditions in your Linq.</li>\n</ul>\n<p>source : <a href=\"https://stackoverflow.com/questions/17968469/whats-the-differences-between-tolist-asenumerable-asqueryable\">https://stackoverflow.com/questions/17968469/whats-the-differences-between-tolist-asenumerable-asqueryable</a></p>\n", "slug": "entity-framework-tolist-vs-asenumerable-vs-asqueryable", "date": 1557438869, "cats": [12, 13, 14]}