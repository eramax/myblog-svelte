{"title": "Exercises in Programming Style", "content": "<p>In the\u00a0<a href=\"https://henrikwarne.com/2016/11/08/developer-book-club/\">book club at work</a>, we recently finished reading\u00a0<a href=\"https://www.amazon.com/Exercises-Programming-Style-Cristina-Videira/dp/1482227371/\">Exercises in Programming Style</a>\u00a0by Cristina Videira Lopes. The book consists of a simple program implemented in 33 different programming styles. It is a great way of showing the different styles, and the book was quite popular in the book club. The book is relatively new (it was published in 2014), and I don\u2019t think it is as well-known as it deserves to be. So here is a summary and review of it.<img class=\"size-full wp-image-194 alignright\" title=\"Exercises in Programming Style\" src=\"https://emolike.net/wp-content/uploads/2018/03/exercises-in-programming-style.jpg\" alt=\"\" width=\"332\" height=\"444\" srcset=\"https://emolike.net/wp-content/uploads/2018/03/exercises-in-programming-style.jpg 332w, https://emolike.net/wp-content/uploads/2018/03/exercises-in-programming-style-224x300.jpg 224w, https://emolike.net/wp-content/uploads/2018/03/exercises-in-programming-style-200x267.jpg 200w\" sizes=\"(max-width: 332px) 100vw, 332px\" /><span id=\"more-1626\"></span></p>\n<h3>ORGANIZATION</h3>\n<p>The inspiration is a book from the 1940s by the French writer Raymond Queneau called\u00a0<a href=\"https://www.amazon.com/Exercises-Style-Raymond-Queneau/dp/0811207897/\">Exercises in Style</a>. In it, he tells the same short story in 99 different styles. Exercises in Programming Style uses the same concept, but implements a short program in 33 different programming styles. Each style is defined by what constraints it imposes on the program.</p>\n<p>The program counts the occurrences of words (term frequencies) in a file. The sample input is the book\u00a0<em>Pride and Prejudice</em>\u00a0taken from the Gutenberg Collection. The program reads input words from a file, removes all non-alphanumeric characters, normalizes (down-cases) the words, removes stop words (\u201cthe\u201d, \u201ca\u201d, \u201cfor\u201d etc), counts the occurrences of all words, and finally prints out the 25 most common words in order.</p>\n<p>All implementations are in Python, and most programs are one or two pages in the book. The size of the task is just right \u2013 it takes a little bit of programming logic, but it is small enough to quickly get familiar with. At the same time it is enough to be able to express the logic in all the different styles covered.</p>\n<p>Each style is presented in its own chapter and in the same way. First the constraints of the style are given. Then the complete program in this style is listed, with line numbers, followed by an explanation of its key features. Next there are comments on the use of this style, historical notes, further reading, a glossary and exercises.</p>\n<h3>STYLES</h3>\n<p>The different styles are grouped together into nine categories. Here is a description of the categories and the styles:</p>\n<p><strong>Historical.</strong>\u00a0The first program in this category has the constraints of very little memory, and no identifiers. There is only memory, addressable with numbers. The result is a program that in many ways looks like assembler. The second style has a data stack, and all operations are done over data on the stack.</p>\n<p><strong>Basic Styles.</strong>\u00a0There are three styles here that show how programming has developed. The first style is\u00a0<em>Monolithic</em>, where the program is not sub-divided in functions. Instead, the logic is just in one long sequence of statements. In the next style, the logic is divided into functions, but all functions operate on shared global variables. In the third style, called\u00a0<em>Pipeline</em>, the functions don\u2019t communicate using global data. Instead, they receive input and produce output. The program then becomes a long chain of function calls. This section also contains\u00a0<em>Code Golf</em>, where the emphasis is on short and compact programs (in this case using libraries to achieve the goal).</p>\n<p><strong>Function Composition.\u00a0</strong>This section shows three different ways of connecting function calls together. The first uses recursion. The second uses a continuation-passing style, where each function is also given the next function that should be called. This resulting program is a bit hard to read because of this. The third illustrates the concept of a monad, and all function calls and resulting values are done through the monad, creating a calling pipeline.</p>\n<p><strong>Objects and Object Interactions.\u00a0</strong>There are six styles here. The first four are variations on regular object orientation, going from a normal object oriented program and one with abstract classes, to examples of how object orientation can be implemented (for example, how you find the method to call, and how the methods of an object are stored). Then there is an example of where you register for a callback, and a version with infrastructure for publish and subscribe.</p>\n<p><strong>Reflection and Metaprogramming.\u00a0</strong>The theme here is programs accessing and changing themselves as they execute.\u00a0 The first example of this style uses introspection (<em>inspect.stack()</em>\u00a0in Python) to check the calling function name. The second uses\u00a0<em>exec/eval</em>\u00a0to build functions from strings containing Python code. The third example uses Python decorators to show how profiling of functions can be done, i.e. Aspect Oriented Programming (the author is one of the creators of AOP). The final program is an example of a plugin architecture, where functions from external files are brought in via a config file.</p>\n<p><strong>Adversity.</strong>\u00a0Here, various error handling strategies are showcased. In the first example, when an error is encountered, an attempt is made to continue with a \u201creasonable\u201d default value. The next throws an exception on every error, and the third also throws exceptions, but tries to handle the errors at a higher level. There is a good discussion on the pros and cons of these strategies, and how it is easier or harder to implement, depending on if the language supports exceptions. There is also an example with types, but this becomes very awkward to show in Python. Finally there is an example where all IO is quarantined, inspired by the design philosophy of Haskell\u2019s IO monad.</p>\n<p><strong>Data-Centric.</strong>\u00a0In this section, the data, rather than the program behavior, is in focus. The first example solves the task by putting all the words in a database, and uses SQL queries to find the top words. The next style emulates a spreadsheet, where changed values trigger recalculation of dependent values. The final example works on data available as a stream (as opposed to getting the complete data at the beginning). In other words, the data is \u201cpulled\u201d by the sink, not pushed from the source. This is solved nicely with generators (using\u00a0<em>yield</em>) in Python.</p>\n<p><strong>Concurrency.</strong>\u00a0This parts starts with one of my favorite paradigms, actors. Different threads send and receive messages to solve the task, and there is no shared memory between them. The downside of this example is that it is quite hard to follow the program flow. The next three examples use data spaces and map reduce (in two variations) to partition the task and then collect the results.</p>\n<p><strong>Interactivity.</strong>\u00a0The final two examples allow for interactive usage. The first is an MVC (Model View Controller) version, although the view simply prints to the console (no GUI). The second is a REST solution, in the purest form, meaning that at each interaction, the next allowed actions are always presented to be selected from. Both these examples brought home the key points really well.</p>\n<h3>OBSERVATIONS</h3>\n<p>I have read quite a lot of books on programming, but this book is unique among them. I really like the approach of showcasing various programming styles and paradigms by implementing the same program in different ways. First, there is a concrete program to look at for each case, instead of just a verbal description. Second, seeing all the programs next to each other highlights the differences in a very accessible way.</p>\n<p>At work we use Python, so all of us already knew Python when reading the book. It was quite convenient to already be familiar with the language used, but I think the book works well even if you don\u2019t know Python. There are a few quirks, for example with classes in Python, but the author explains those when needed. The only time Python was a problem was when showing how types protect against errors in the\u00a0<em>Adversity</em>\u00a0section.</p>\n<p>When it came to understanding the programs, there was always a very good section called\u00a0<em>Commentary</em>\u00a0that explained in detail how each program worked. For the most part though, I preferred to just start reading the code and see if I understood how it worked. Usually this was enough, but sometimes I missed not having an IDE for searching for usages etc. I could have done that though, because all of the programs are available on\u00a0<a href=\"https://github.com/crista/exercises-in-programming-style\">GitHub</a>.</p>\n<p>For each style there were references and historical notes. These were quite good and interesting. In particular it was surprising that there were so many references to papers and books from the 50s and 60s. There were also a lot of references to Smalltalk, and to Dijkstra.</p>\n<p>Before reading the book, I decided to implement\u00a0<a href=\"https://github.com/henrikw/exercises-in-programming-style/blob/master/word_count.py\">my own version</a>\u00a0of the term frequency program. This gave me an slightly better understanding of what is needed to solve the problem. Mostly though, it was for the fun of seeing which style my solution was written in. The best match turned out to be\u00a0<em>Pipeline</em>\u00a0in\u00a0<em>Basic Styles</em>. Also, when testing my solution I noticed that the\u00a0<em>Pride and Prejudice</em>\u00a0sample input the author is using also includes a few Project Gutenberg sentences in addition to the book text. I found this slightly disappointing.</p>\n<p>My only criticism of the book is the naming of the styles. Naming is\u00a0<a href=\"https://martinfowler.com/bliki/TwoHardThings.html\">famously hard</a>, but also very important, because the names help you remember the styles better and makes discussing them easier. In many cases, there are already establish names for the styles, but instead of using them, the author came up with her own. For example:\u00a0<em>Trinity</em>\u00a0instead of\u00a0<em>MVC</em>,\u00a0<em>Things</em>\u00a0instead of\u00a0<em>Objects</em>,\u00a0<em>Hollywood</em>\u00a0instead of\u00a0<em>Callbacks</em>,\u00a0<em>Bulletin Board</em>\u00a0instead of\u00a0<em>Pub/Sub</em>\u00a0and\u00a0<em>Kick Forward</em>\u00a0instead of\u00a0<em>Continuation-passing</em>. Those names are OK, but it is much better to stick to the industry standard ones.</p>\n<h3>CONCLUSION</h3>\n<p>I really enjoyed this book. It is unique in its approach, and it really succeeds in showing a wide variety of programming styles in just the right amount of code. Seeing the concepts implemented, and being able to compare them easily, is the main strength. At around 300 pages it manages to explain a lot in a concise way. Well done!</p>\n<blockquote><p>https://henrikwarne.com/2016/11/08/developer-book-club/</p></blockquote>\n", "slug": "exercises-in-programming-style", "date": 1521045510, "cats": [0, 14]}