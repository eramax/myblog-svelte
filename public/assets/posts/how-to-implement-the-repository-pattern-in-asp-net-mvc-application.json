{"title": "How to Implement the Repository Pattern in ASP.NET MVC Application", "content": "<p>The Repository Pattern is one of the most popular patterns to create an enterprise level application. It restricts us to work directly with the data in the application and creates new layers for database operations, business logic, and the application\u2019s UI. If an application does not follow the Repository Pattern, it may have the following problems:</p>\n<ul>\n<li>Duplicate database operations codes</li>\n<li>Need of UI to unit test database operations and business logic</li>\n<li>Need of External dependencies to unit test business logic</li>\n<li>Difficult to implement database caching, etc.</li>\n</ul>\n<p>Using the Repository Pattern has many advantages:</p>\n<ul>\n<li>Your business logic can be unit tested without data access logic;</li>\n<li>The database access code can be reused;</li>\n<li>Your database access code is centrally managed so easy to implement any database access policies, like caching;</li>\n<li>It\u2019s easy to implement domain logic;</li>\n<li>Your domain entities or business entities are strongly typed with annotations; and more.</li>\n</ul>\n<p>On the internet, there are millions of articles written around Repository Pattern, but in this one, we\u2019re going to focus on how to implement it in an ASP.NET MVC Application. So let\u2019s get started!</p>\n<p><b>Project Structure</b></p>\n<p>Let us start with creating the Project structure for the application. We are going to create four projects:</p>\n<ol>\n<li>Core Project</li>\n<li>Infrastructure Project</li>\n<li>Test Project</li>\n<li>MVC Project</li>\n</ol>\n<p>Each project has its own purpose. You can probably guess by the projects\u2019 names what they\u2019ll contain: Core and Infrastructure projects are Class Libraries, Web project is an MVC project, and Test project is a Unit Test project. Eventually, the projects in the solution explorer will look as shown in the image below:</p>\n<p><img class=\"alignnone size-full wp-image-1154\" src=\"https://emolike.net/wp-content/uploads/2018/12/3857.pic1_.png\" alt=\" \" width=\"398\" height=\"277\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/3857.pic1_.png 398w, https://emolike.net/wp-content/uploads/2018/12/3857.pic1_-300x209.png 300w, https://emolike.net/wp-content/uploads/2018/12/3857.pic1_-388x270.png 388w\" sizes=\"(max-width: 398px) 100vw, 398px\" /></p>\n<p>As we progress in this post, we will learn in detail about the purpose of each project, however, to start we can summarize the main objective of each project as the following:</p>\n<p><img class=\"alignnone size-full wp-image-1155\" src=\"https://emolike.net/wp-content/uploads/2018/12/2352.pic2_.png\" alt=\" \" width=\"883\" height=\"387\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/2352.pic2_.png 883w, https://emolike.net/wp-content/uploads/2018/12/2352.pic2_-300x131.png 300w, https://emolike.net/wp-content/uploads/2018/12/2352.pic2_-768x337.png 768w, https://emolike.net/wp-content/uploads/2018/12/2352.pic2_-604x265.png 604w\" sizes=\"(max-width: 883px) 100vw, 883px\" /></p>\n<p>So far our understanding for different projects is clear. Now let us go ahead and implement each project one by one. During the implementations, we will explore the responsibilities of each project in detail.</p>\n<p> </p>\n<p><b>Core Project</b></p>\n<p>In the core project, we keep the entities and the repository interfaces or the database operation interfaces. The core project contains information about the domain entities and the database operations required on the domain entities. In an ideal scenario, the core project should not have any dependencies on external libraries. It must not have any business logic, database operation codes etc.</p>\n<p>In short, the core project should contain:</p>\n<ul>\n<li>Domain entities</li>\n<li>Repository interfaces or database operations interfaces on domain entities</li>\n<li>Domain-specific data annotations</li>\n</ul>\n<p>The core project can NOT contain:</p>\n<ul>\n<li>Any external libraries for database operations</li>\n<li>Business logic</li>\n<li>Database operations code</li>\n</ul>\n<p>While creating the domain entities, we also need to make a decision on the restrictions on the domain entities properties, for example:</p>\n<ul>\n<li>Whether a particular property is required or not. For instance, for a Product entity, the name of the product should be required property.</li>\n<li>Whether a value of a particular property is in given range or not. For instance, for a Product entity, the price property should be in given range.</li>\n<li>Whether the maximum length of a particular property should not be given value. For instance, for a Product entity, the name property value should be less than the maximum length.</li>\n</ul>\n<p>There could be many such data annotations on the domain entities properties. There are two ways we can think about these data annotations:</p>\n<ol>\n<li>As part of the domain entities</li>\n<li>As part of the database operations logic</li>\n</ol>\n<p>It is purely up to us how we see data annotations. If we consider them part of database operation then we can apply restrictions using database operation libraries API. We are going to use the Entity Framework for database operations in the Infrastructure project, so we can use Entity Framework Fluent API to annotate data.</p>\n<p>If we consider them part of the domain, then we can use\u00a0<b>System.ComponentModel.DataAnnotations</b>\u00a0library to annotate the data. To use this, right click on the Core project\u2019s Reference folder and click on Add Reference. From the Framework tab, select\u00a0<b>System.ComponentModel.DataAnnotations\u00a0</b>and add to the project.</p>\n<p>We are creating a ProductApp, so let us start with creating the Product entity. To add an entity class, right click on the Core project and add a class, then name the class Product.</p>\n<pre><code data-enlighter-language=\"csharp\">using System.ComponentModel.DataAnnotations;\r\nnamespace ProductApp.Core\r\n{\r\n    public class Product\r\n    {\r\n        public int Id { get; set; }\r\n [Required]\r\n [MaxLength(100)]\r\n        public string Name { get; set; }\r\n [Required]\r\n        public double Price { get; set; }\r\n        public bool inStock { get; set; }\r\n    }\r\n}</code></pre>\n<p>We have annotated the Product entity properties with\u00a0<b>Required</b>\u00a0and\u00a0<b>MaxLength</b>. Both of these annotations are part of\u00a0<b>System.ComponentModel.DataAnnotations</b>. Here, we have considered restriction as part of the domain, hence used data annotations in the core project itself.</p>\n<p>We have created Product Entity class and also applied data annotation to that. Now let us go ahead and create Repository interface. But before we create that, let us understand, what is a Repository Interface?</p>\n<p>The repository interface defines all the database operations possible on the domain entities. All database operations that can be performed on the domain entities are part of the domain information, hence we will put the repository interface in the core project. How these operations can be performed will be the part of the Infrastructure project.</p>\n<p>To create a Repository Interface, right click on the Core project and add a folder named Interfaces. Once the Interfaces folder is created, right click on the Interface folder and select add a new item, then from the Code tab select Interface. Name the Interface\u00a0<b>IProductRepository</b></p>\n<div>\n<pre><code data-enlighter-language=\"csharp\">using System.Collections.Generic;\r\n\r\nnamespace ProductApp.Core.Interfaces\r\n{\r\n    public interface IProductRepository\r\n    {\r\n        void Add(Product p);\r\n        void Edit(Product p);\r\n        void Remove(int Id);\r\n        IEnumerable GetProducts(); Product FindById(int Id); } } \r\n</code></pre>\n<p>Now we have created a Product entity class and a Product Repository Interface. At this point, the core project should look like this:</p>\n<p><img class=\"alignnone size-full wp-image-1156\" src=\"https://emolike.net/wp-content/uploads/2018/12/8228.pic3_.png\" alt=\" \" width=\"348\" height=\"279\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/8228.pic3_.png 348w, https://emolike.net/wp-content/uploads/2018/12/8228.pic3_-300x241.png 300w, https://emolike.net/wp-content/uploads/2018/12/8228.pic3_-337x270.png 337w\" sizes=\"(max-width: 348px) 100vw, 348px\" /></p>\n<p>Let us go ahead and build the core project to verify everything is in place and move ahead to create Infrastructure project.</p>\n<p> </p>\n<p><b>Infrastructure Project</b></p>\n<p>The main purpose of Infrastructure project is to perform database operations. Besides database operations, it can also consume web services, perform IO operations etc. So mainly, Infrastructure project may perform the following operations:</p>\n<ul>\n<li>Database operations</li>\n<li>Working with WCF and Web Services</li>\n<li>IO operations</li>\n</ul>\n<p>We can use any database technology to perform database operations. In this post, we are going to use Entity Framework. So we are going to create a database using the Code First approach. In the Code First approach, the database gets created on basis of the classes. Here database will be created on the basis of the Domain entities from the Core Project.</p>\n<p>To create the database from the Core project domain entity, we need to perform these tasks:</p>\n<ol>\n<li>Create DataContext class</li>\n<li>Configure the connection string</li>\n<li>Create DataBase Initializer class to seed data in the database</li>\n<li>Implement IProductRepsitory interface</li>\n</ol>\n<p><b>\u00a0</b></p>\n<p><b>Adding References</b></p>\n<p>First, let\u2019s add references to the Entity Framework and ProductApp.Core project. To add the Entity Framework, right click on the Infrastructure project and click on Manage Nuget Package. In the Package Manager Window, search for Entity Framework and install the latest stable version.</p>\n<p>To add a reference of the ProductApp.Core project, right click on the Infrastructure project and click on Add Reference. In the Reference Window, click on the Project tab and select ProductApp.Core.</p>\n<p><b>DataContext class</b></p>\n<p>The objective of the DataContext class is to create the DataBase in the Entity Framework Code First approach. We pass a connection string in the constructor of DataContext class. By reading the connection string, the Entity Framework creates the database. If a connection string is not specified then the Entity Framework creates the database in a local database server.</p>\n<p>In the DataContext class:</p>\n<ul>\n<li>Create a DbSet type property. This is responsible for creating the table for the Product entity</li>\n<li>In the constructor of the DataContext class, pass the connection string to specify information to create a database, for example, server name, database name, login information etc. We need to pass the name of the connection string. name where the database would be created</li>\n<li>If connection string is not passed, Entity Framework creates with the name of data context class in the local database server.</li>\n<li>The productdatacontext class inherits the DbContext class</li>\n</ul>\n<p>The ProductDataContext class can be created as shown in the listing below:</p>\n<pre><code data-enlighter-language=\"csharp\">using ProductApp.Core;\r\nusing System.Data.Entity;\r\n\r\nnamespace ProductApp.Infrastructure\r\n{\r\n    public class ProductContext  : DbContext\r\n    {\r\n        public ProductContext()\r\n           : base(\"name=ProductAppConnectionString\")\r\n       {\r\n       }\r\n        public DbSet Products { get; set; } } }</code></pre>\n<p>Next, we need to work on the Connection String. As discussed earlier, we can either pass the connection string to specify database creation information or reply on the Entity Framework to create default database at default location for us. We are going to specify the connection string that is why we passed a connection string name ProductAppConnectionString in the constructor of ProductDataContext class. In the App.Config file the ProductAppConnectionString connection string can be created as shown in the listing below:</p>\n<pre><code data-enlighter-language=\"null\">&lt;add name=\"ProductAppConnectionString\" connectionString=\"Data Source=(LocalDb)\\v11.0;Initial Catalog=ProductAppJan;Integrated Security=True;MultipleActiveResultSets=true\" providerName=\"System.Data.SqlClient\"/&gt;\r\n</code></pre>\n<p><b>Database Initializer class</b></p>\n<p>We create a database initializer class to seed the database with some initial value at the time of the creation. To create the Database initializer class, create a class which inherits from\u00a0<b>DropCreateDatabaseIfModelChnages</b>. There are other options of classes available to inherit in order to create a database initializer class. If we inherit DropCreateDatabaseIfModelChnages class then each time a new database will be created on the model changes. So for example, if we add or remove properties from the Product entity class, Entity Framework will drop the existing database and create a new one. Of course, this is not a great option, since data will be lost too, so I recommend you explore other options to inherit the database initializer class.</p>\n<p>The database initializer class can be created as shown in the listing below. Here we are seeding the product table with two rows. To seed the data:</p>\n<ol>\n<li>Override Seed method</li>\n<li>Add product to Context.Products</li>\n<li>Call Context.SaveChanges()</li>\n</ol>\n<pre><code data-enlighter-language=\"csharp\">using ProductApp.Core;\r\nusing System.Data.Entity;\r\n\r\nnamespace ProductApp.Infrastructure\r\n{\r\n    public class ProductInitalizeDB : DropCreateDatabaseIfModelChanges { protected override void Seed(ProductContext context) { context.Products.Add(new Product { Id = 1, Name = \"Rice\", inStock = true, Price = 30 }); context.Products.Add(new Product { Id = 2, Name = \"Sugar\", inStock = false, Price = 40 }); context.SaveChanges(); base.Seed(context); } } }</code></pre>\n<p>So far, we have done all the Entity Framework Code First related work to create the database. Now let\u2019s go ahead and implement an IProductRepository interface from the Core project in a concrete ProductRepository class.</p>\n<p> </p>\n<p><b>Repository Class</b></p>\n<p>This is the class which will perform database operations on the Product Entity. In this class, we will implement the IProductRepository interface from the Core project. Let us start with adding a class ProductRepository to the Infrastructure project and implement the IProductRepository interface. To perform database operations, we are going to write simple LINQ to Entity queries. The product repository class can be created as shown in the listing below:</p>\n<div>\n<pre><code data-enlighter-language=\"csharp\">using ProductApp.Core.Interfaces;\r\nusing System.Collections.Generic;\r\nusing System.Linq;\r\nusing ProductApp.Core;\r\n\r\nnamespace ProductApp.Infrastructure\r\n{\r\n    public class ProductRepository : IProductRepository\r\n    {\r\n        ProductContext context = new ProductContext();\r\n        public void Add(Product p)\r\n        {\r\n            context.Products.Add(p);\r\n            context.SaveChanges();\r\n        }\r\n\r\n        public void Edit(Product p)\r\n        {\r\n            context.Entry(p).State = System.Data.Entity.EntityState.Modified;\r\n        }\r\n\r\n        public Product FindById(int Id)\r\n        {\r\n            var result = (from r in context.Products where r.Id == Id select r).FirstOrDefault();\r\n            return result;\r\n        }\r\n\r\n        public IEnumerable GetProducts() { return context.Products; } public void Remove(int Id) { Product p = context.Products.Find(Id); context.Products.Remove(p); context.SaveChanges(); } } }</code></pre>\n<p>So far we have created a Data Context class, a Database Initializer class, and the Repository class. Let us build the infrastructure project to make sure that everything is in place. The ProductApp.Infrastructure project will look as given in the below image:</p>\n<p><img class=\"alignnone size-full wp-image-1157\" src=\"https://emolike.net/wp-content/uploads/2018/12/5657.pic4_.png\" alt=\" \" width=\"394\" height=\"196\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/5657.pic4_.png 394w, https://emolike.net/wp-content/uploads/2018/12/5657.pic4_-300x149.png 300w\" sizes=\"(max-width: 394px) 100vw, 394px\" /></p>\n<p>Now we\u2019re done creating the Infrastructure project. We have written all the database operations-related classes inside the Infrastructure project, and all the database-related logic is in a central place. Whenever any changes in database logic are required, we need to change only the infrastructure project.</p>\n<p> </p>\n<p><b>Test Project</b></p>\n<p>The biggest advantage of Repository Pattern is the testability. This allows us to unit test the various components without having dependencies on other components of the project. For example, we have created the Repository class which performs the database operations to verify the correctness of the functionality, so we should unit test it. We should also be able to write tests for the Repository class without any dependency on the web project or UI. Since we are following the Repository Pattern, we can write Unit Tests for the Infrastructure project without any dependency on the MVC project (UI).</p>\n<p>To write Unit Tests for ProductRepository class, let us add following references in the Test project.</p>\n<ol>\n<li>Reference of ProductApp.Core project</li>\n<li>Reference of ProductApp.Infrastructure project</li>\n<li>Entity Framework package</li>\n</ol>\n<p> </p>\n<p>To add the Entity Framework, right click on the Test project and click on Manage Nuget Package. In the Package Manager Windows, search for Entity Framework and install the latest stable version.</p>\n<p>To add a reference of the ProductApp.Core project, right click on the Test project and click on Add Reference. In the Reference Window, click on Project tab and select ProductApp.Core.</p>\n<p>To add a reference of the ProductApp.Infrastructure project, right click on the Test project and click on Add Reference. In the Reference Window, click on Project tab and select ProductApp.Infrastructure.</p>\n<p><b>Copy the Connection String</b></p>\n<p>Visual Studio always reads the config file of the running project. To test the Infrastructure project, we will run the Test project. Hence the connection string should be part of the App.Config of the Test project. Let us copy and paste the connection string from Infrastructure project in the Test project.</p>\n<p>We have added all the required references and copied the connection string. Let\u2019s go ahead now and set up the Test Class. We\u2019ll create a Test Class with the name ProductRepositoryTest.\u00a0<i>Test Initialize</i>\u00a0is the function executed before the tests are executed. We need to create an instance of the ProductRepository class and call the ProductDbInitalize class to seed the data before we run tests. Test Initializer can be written as shown in the listing below:</p>\n<pre><code data-enlighter-language=\"csharp\">[TestClass]\r\n    public class ProductRepositoryTest\r\n    {\r\n        ProductRepository Repo; \r\n [TestInitialize]\r\n        public void TestSetup()\r\n        {\r\n            ProductInitalizeDB db = new ProductInitalizeDB();\r\n            System.Data.Entity.Database.SetInitializer(db);\r\n            Repo = new ProductRepository();\r\n        }\r\n    }</code></pre>\n</div>\n<p>Now we\u2019ve written the Test Initializer. Now let write the very first test to verify whether ProductInitalizeDB class seeds two rows in the Product table or not. Since it is the first test we will execute, it will also verify whether the database gets created or not. So essentially we are writing a test:</p>\n<ol>\n<li>To verify database creation</li>\n<li>To verify the number of rows inserted by the seed method of Product Database Initializer</li>\n</ol>\n<div>\n<pre><code data-enlighter-language=\"csharp\">[TestMethod]\r\n        public void IsRepositoryInitalizeWithValidNumberOfData()\r\n        {\r\n            var result = Repo.GetProducts();\r\n            Assert.IsNotNull(result);\r\n            var numberOfRecords = result.ToList().Count;\r\n            Assert.AreEqual(2, numberOfRecords);\r\n        }</code></pre>\n<p>As you can see, we\u2019re calling the Repository GetProducts() function to fetch all the Products inserted while creating the database. This test is actually verifying whether GetProducts() works as expected or not, and also verifying database creation. In the Test Explorer window, we can run the test for verification.</p>\n<p><img class=\"alignnone size-full wp-image-1158\" src=\"https://emolike.net/wp-content/uploads/2018/12/6253.pic5_.png\" alt=\" \" width=\"792\" height=\"249\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/6253.pic5_.png 792w, https://emolike.net/wp-content/uploads/2018/12/6253.pic5_-300x94.png 300w, https://emolike.net/wp-content/uploads/2018/12/6253.pic5_-768x241.png 768w, https://emolike.net/wp-content/uploads/2018/12/6253.pic5_-604x190.png 604w\" sizes=\"(max-width: 792px) 100vw, 792px\" /></p>\n<p>To run the test, first build the Test project, then from the top menu select Test-&gt;Windows-Test Explorer. In the Test Explorer, we will find all the tests listed. Select the test and click on Run.</p>\n<p>Let\u2019s go ahead and write one more test to verify Add Product operation on the Repository:</p>\n<pre><code data-enlighter-language=\"csharp\">[TestMethod]\r\n        public void IsRepositoryAddsProduct()\r\n        {\r\n            Product productToInsert = new Product\r\n            {\r\n                Id = 3,\r\n                inStock = true,\r\n                Name = \"Salt\",\r\n                Price = 17\r\n\r\n            };\r\n            Repo.Add(productToInsert);\r\n            // If Product inserts successfully, \r\n            //number of records will increase to 3 \r\n            var result = Repo.GetProducts();\r\n            var numberOfRecords = result.ToList().Count;\r\n            Assert.AreEqual(3, numberOfRecords);\r\n        }</code></pre>\n<p>To verify insertion of the Product, we are calling the Add function on the Repository. If Product gets added successfully, the number of records will increase to 3 from 2 and we are verifying that. On running the test, we will find that the test has been passed.</p>\n<p><img class=\"alignnone size-full wp-image-1159\" src=\"https://emolike.net/wp-content/uploads/2018/12/3326.pic6_.png\" alt=\" \" width=\"792\" height=\"257\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/3326.pic6_.png 792w, https://emolike.net/wp-content/uploads/2018/12/3326.pic6_-300x97.png 300w, https://emolike.net/wp-content/uploads/2018/12/3326.pic6_-768x249.png 768w, https://emolike.net/wp-content/uploads/2018/12/3326.pic6_-604x196.png 604w\" sizes=\"(max-width: 792px) 100vw, 792px\" /></p>\n<p>In this way, we can write tests for all the Database operations from the Product Repository class. Now we are sure that we have implemented the Repository class correctly because tests are passing, which means the Infrastructure and Core project can be used with any UI (in this case MVC) project.</p>\n<p> </p>\n<p><b>MVC or Web Project</b></p>\n<p>Finally, we have gotten to the MVC project! Like the Test project, we need to add following references</p>\n<ol>\n<li>Reference of ProductApp.Core project</li>\n<li>Reference of ProductApp.Infrastructure project</li>\n</ol>\n<p>To add a reference of the ProductApp.Core project, right click on the MVC project and click on Add Reference. In the Reference Window, click on Project tab and select ProductApp.Core.</p>\n<p>To add a reference of the ProductApp.Infrastructure project, right click on the MVC project and click on Add Reference. In the Reference Window, click on Project tab and select ProductApp.Infrastructure.</p>\n<p><b>\u00a0</b></p>\n<p><b>Copy the Connection String</b></p>\n<p>Visual Studio always reads the config file of the running project. To test the Infrastructure project, we will run the Test project, so the connection string should be part of the App.Config of the Test project. To make it easier, let\u2019s copy and paste the connection string from Infrastructure project in the Test project.</p>\n<p> </p>\n<p><b>Scaffolding the Application</b></p>\n<p>We should have everything in place to scaffold the MVC controller. To scaffold, right click on the Controller folder and select MVC 5 Controller with Views, using Entity Framework as shown in the image below:</p>\n<p><b><img class=\"alignnone size-full wp-image-1160\" src=\"https://emolike.net/wp-content/uploads/2018/12/2746.pic7_.png\" alt=\" \" width=\"992\" height=\"560\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/2746.pic7_.png 992w, https://emolike.net/wp-content/uploads/2018/12/2746.pic7_-300x169.png 300w, https://emolike.net/wp-content/uploads/2018/12/2746.pic7_-768x434.png 768w, https://emolike.net/wp-content/uploads/2018/12/2746.pic7_-478x270.png 478w\" sizes=\"(max-width: 992px) 100vw, 992px\" /></b></p>\n<p>Next, we will see the Add Controller window. Here we need to provide the Model Class and Data context class information. In our project, model class is the Product class from the Core project and the Data context class is the ProductDataContext class from the Infrastructure project. Let us select both the classes from the drop-down as shown in the image below:</p>\n<p><img class=\"alignnone size-full wp-image-1161\" src=\"https://emolike.net/wp-content/uploads/2018/12/1351.pic8_.png\" alt=\" \" width=\"738\" height=\"477\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/1351.pic8_.png 738w, https://emolike.net/wp-content/uploads/2018/12/1351.pic8_-300x194.png 300w, https://emolike.net/wp-content/uploads/2018/12/1351.pic8_-418x270.png 418w\" sizes=\"(max-width: 738px) 100vw, 738px\" /></p>\n<p>Also, we should make sure that the Generate Views, Reference script libraries, and Use a layout page options are selected.</p>\n<p>On clicking Add, Visual Studio will create the ProductsController and Views inside Views/Products folder. The MVC project should have the structure shown in the image below:</p>\n<p><img class=\"alignnone size-full wp-image-1162\" src=\"https://emolike.net/wp-content/uploads/2018/12/4578.pic9_.png\" alt=\" \" width=\"371\" height=\"436\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/4578.pic9_.png 371w, https://emolike.net/wp-content/uploads/2018/12/4578.pic9_-255x300.png 255w, https://emolike.net/wp-content/uploads/2018/12/4578.pic9_-230x270.png 230w\" sizes=\"(max-width: 371px) 100vw, 371px\" /></p>\n<p>At this point, if we go ahead and run the application, we will be able to perform CRUD operations on the Product entity.</p>\n<p><img class=\"alignnone size-full wp-image-1163\" src=\"https://emolike.net/wp-content/uploads/2018/12/4062.pic10.png\" alt=\" \" width=\"937\" height=\"454\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/4062.pic10.png 937w, https://emolike.net/wp-content/uploads/2018/12/4062.pic10-300x145.png 300w, https://emolike.net/wp-content/uploads/2018/12/4062.pic10-768x372.png 768w, https://emolike.net/wp-content/uploads/2018/12/4062.pic10-557x270.png 557w\" sizes=\"(max-width: 937px) 100vw, 937px\" /></p>\n<p><b>Problem with Scaffolding</b></p>\n<p>But we are not done yet! Let\u2019s open the ProductsController class and examine the code. On the very first line, we will find the problem. Since we have used MVC scaffolding, MVC is creating an object of the ProductContext class to perform the database operations.</p>\n<p><img class=\"alignnone size-full wp-image-1164\" src=\"https://emolike.net/wp-content/uploads/2018/12/4544.pic11.png\" alt=\" \" width=\"632\" height=\"302\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/4544.pic11.png 632w, https://emolike.net/wp-content/uploads/2018/12/4544.pic11-300x143.png 300w, https://emolike.net/wp-content/uploads/2018/12/4544.pic11-565x270.png 565w\" sizes=\"(max-width: 632px) 100vw, 632px\" /></p>\n<p>Any dependencies on the context class bind the UI project and the Database tightly to each other. As we know the Datacontext class is an Entity Framework component. We do not want the MVC project to know which database technology is being used in the Infrastructure project. On the other hand, we haven\u2019t tested the Datacontext class; we\u2019ve tested the ProductRepository class. Ideally, we should use ProductRepository class instead of the ProductContext class to perform database operations in the MVC Controller. \u00a0To summarize,</p>\n<ol>\n<li>MVC Scaffolding uses Data context class to perform database operations. The data context class is an Entity Framework component, so its use tightly couples UI (MVC) with the Database (EF) technology.</li>\n<li>The data context class is not unit tested so it\u2019s not a good idea to use that.</li>\n<li>We have a tested ProductRepository class. We should use this inside Controller to perform database operations. Also, the ProductRepository class does not expose database technology to the UI.</li>\n</ol>\n<p>To use the ProductRepository class for database operations, we need to refactor the ProductsController class. To do so, there are two steps we need to follow:</p>\n<ol>\n<li>Create an object of ProductRepository class instead of ProductContext class.</li>\n<li>Call methods of ProductRepository class to perform database operations on Product entity instead of methods of ProductContext class.</li>\n</ol>\n<p>In the listing below, I have commented codes using ProductContext and called ProductRepository methods. After refactoring, the ProductController class will look like the following:</p>\n<pre><code data-enlighter-language=\"csharp\">using System;\r\nusing System.Net;\r\nusing System.Web.Mvc;\r\nusing ProductApp.Core;\r\nusing ProductApp.Infrastructure;\r\n\r\nnamespace ProductApp.Web.Controllers\r\n{\r\n    public class ProductsController : Controller\r\n    {\r\n        //private ProductContext db = new ProductContext();\r\n        private ProductRepository db = new ProductRepository();\r\n\r\n     \r\n        public ActionResult Index()\r\n        {\r\n            //return View(db.Products.ToList());\r\n            return View(db.GetProducts());\r\n        }\r\n\r\n    \r\n        public ActionResult Details(int? id)\r\n        {\r\n            if (id == null)\r\n            {\r\n                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);\r\n            }\r\n            // Product product = db.Products.Find(id);\r\n            Product product = db.FindById(Convert.ToInt32(id));\r\n            if (product == null)\r\n            {\r\n                return HttpNotFound();\r\n            }\r\n            return View(product);\r\n        }\r\n\r\n     \r\n        public ActionResult Create()\r\n        {\r\n            return View();\r\n        }\r\n\r\n [HttpPost]\r\n [ValidateAntiForgeryToken]\r\n        public ActionResult Create([Bind(Include = \"Id,Name,Price,inStock\")] Product product)\r\n        {\r\n            if (ModelState.IsValid)\r\n            {\r\n                // db.Products.Add(product);\r\n                //db.SaveChanges();\r\n                db.Add(product);\r\n                return RedirectToAction(\"Index\");\r\n            }\r\n\r\n            return View(product);\r\n        }\r\n\r\n       \r\n        public ActionResult Edit(int? id)\r\n        {\r\n            if (id == null)\r\n            {\r\n                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);\r\n            }\r\n            Product product = db.FindById(Convert.ToInt32(id));\r\n            if (product == null)\r\n            {\r\n                return HttpNotFound();\r\n            }\r\n            return View(product);\r\n        }\r\n\r\n [HttpPost]\r\n [ValidateAntiForgeryToken]\r\n        public ActionResult Edit([Bind(Include = \"Id,Name,Price,inStock\")] Product product)\r\n        {\r\n            if (ModelState.IsValid)\r\n            {\r\n                //db.Entry(product).State = EntityState.Modified;\r\n                //db.SaveChanges();\r\n                db.Edit(product);\r\n                return RedirectToAction(\"Index\");\r\n            }\r\n            return View(product);\r\n        }\r\n\r\n   \r\n        public ActionResult Delete(int? id)\r\n        {\r\n            if (id == null)\r\n            {\r\n                return new HttpStatusCodeResult(HttpStatusCode.BadRequest);\r\n            }\r\n            Product product = db.FindById(Convert.ToInt32(id));\r\n            if (product == null)\r\n            {\r\n                return HttpNotFound();\r\n            }\r\n            return View(product);\r\n        }\r\n\r\n \r\n [HttpPost, ActionName(\"Delete\")]\r\n [ValidateAntiForgeryToken]\r\n        public ActionResult DeleteConfirmed(int id)\r\n        {\r\n            //Product product = db.FindById(Convert.ToInt32(id));\r\n            // db.Products.Remove(product);\r\n            // db.SaveChanges();\r\n            db.Remove(id);\r\n            return RedirectToAction(\"Index\");\r\n        }\r\n\r\n        protected override void Dispose(bool disposing)\r\n        {\r\n            if (disposing)\r\n            {\r\n                //db.Dispose();\r\n            }\r\n            base.Dispose(disposing);\r\n        }\r\n    }\r\n}</code></pre>\n<p>After refactoring, let\u2019s go ahead and build and run the application \u2013 we should be able to do so and perform the CRUD operations.</p>\n<p><b>Injecting the Dependency</b></p>\n<p>Now we\u2019re happy that the application is up and running, and it was created using the Repository pattern. But there is still a problem: we are directly creating an object of the ProductRepository class inside the ProductsController class, and we don\u2019t want this. We want to invert the dependency and delegate the task of injecting the dependency to a third party, popularly known as a DI container. Essentially, ProductsController will ask the DI container to return the instance of IProductRepository.</p>\n<p>There are many DI containers available for MVC applications. In this example, we\u2019ll use the simplest Unity DI container. To do so, right-click on the MVC project and click Manage Nuget Package. In the NuGet Package Manager search for Unity.Mvc and install the package.</p>\n<p><img class=\"alignnone size-full wp-image-1165\" src=\"https://emolike.net/wp-content/uploads/2018/12/2084.pic12.png\" alt=\" \" width=\"1112\" height=\"408\" srcset=\"https://emolike.net/wp-content/uploads/2018/12/2084.pic12.png 1112w, https://emolike.net/wp-content/uploads/2018/12/2084.pic12-300x110.png 300w, https://emolike.net/wp-content/uploads/2018/12/2084.pic12-768x282.png 768w, https://emolike.net/wp-content/uploads/2018/12/2084.pic12-1024x376.png 1024w, https://emolike.net/wp-content/uploads/2018/12/2084.pic12-604x222.png 604w\" sizes=\"(max-width: 1112px) 100vw, 1112px\" /></p>\n<p>Once the Unity.Mvc package is installed, let us go ahead and open an App_Start folder. Inside the App_Start folder, we will find the UnityConfig.cs file. In the UnityConfig class, we have to register the type. To do so, open RegisterTypes function in UnityConfig class and register the type as shown in the listing below:</p>\n<pre><code data-enlighter-language=\"csharp\">public static void RegisterTypes(IUnityContainer container)\r\n        {\r\n            \r\n\r\n            // TODO: Register your types here\r\n            container.RegisterType&lt;iproductrepository, productrepository=\"\"&gt;(); }</code></pre>\n<p>We have registered the type to Unity DI container. Now let us go ahead and do a little bit of refactoring in the ProductsController class. \u00a0In the constructor of ProductsController, we will pass the reference to the repository interface. Whenever required by the application, the Unity DI container will inject the concrete object of ProductRepository in the application by resolving the type. We need to refactor the ProductsController as shown in the listing below:</p>\n<pre><code data-enlighter-language=\"csharp\">public class ProductsController : Controller\r\n   {\r\n       IProductRepository db;\r\n       public ProductsController(IProductRepository db)\r\n       {\r\n\r\n           this.db = db;\r\n       }</code></pre>\n<p>Let us go ahead and build and run the application. We should have the application up and running, and we should able to perform CRUD operations using Repository Pattern and Dependency Injection!</p>\n<p><b>Conclusion</b></p>\n<p>In this article, we learned in a step by step manner how to create an MVC application following the Repository pattern. In doing so, we can put all the database logic in one place and whenever required, we only need to change the repository and test that. The Repository Pattern also loosely couples the application UI with the Database logic and the Domain entities and makes your application more testable.</p>\n<p>\u064dSource :\u00a0<a href=\"https://www.infragistics.com/community/blogs/b/dhananjay_kumar/posts/how-to-implement-the-repository-pattern-in-asp-net-mvc-application\">https://www.infragistics.com/community/blogs/b/dhananjay_kumar/posts/how-to-implement-the-repository-pattern-in-asp-net-mvc-application</a></p>\n</div>\n</div>\n", "slug": "how-to-implement-the-repository-pattern-in-asp-net-mvc-application", "date": 1543665493, "cats": [0, 13, 14, 18, 17, 25, 15]}