{"title": "Julia, high-performance dynamic programming language for numerical computing", "content": "<p><a href=\"http://julialang.org/\">Julia</a>\u00a0is a high-level, high-performance dynamic programming language for numerical computing. It provides a sophisticated compiler,\u00a0<a href=\"http://docs.julialang.org/en/stable/manual/parallel-computing/\">distributed parallel execution</a>, numerical accuracy, and an\u00a0<a href=\"https://docs.julialang.org/en/latest/#Standard-Library-1\">extensive mathematical function library</a>. Julia\u2019s Base library, largely written in Julia itself, also integrates mature, best-of-breed open source C and Fortran libraries for\u00a0<a href=\"http://docs.julialang.org/en/stable/stdlib/linalg/\">linear algebra</a>,\u00a0<a href=\"http://docs.julialang.org/en/stable/stdlib/numbers/#random-numbers\">random number generation</a>,\u00a0<a href=\"http://docs.julialang.org/en/stable/stdlib/math/#signal-processing\">signal processing</a>, and\u00a0<a href=\"http://docs.julialang.org/en/stable/stdlib/strings/#strings\">string processing</a>. In addition, the Julia developer community is contributing a number of\u00a0<a href=\"http://pkg.julialang.org/\">external packages</a>\u00a0through Julia\u2019s built-in package manager at a rapid pace.\u00a0<a href=\"https://github.com/JuliaLang/IJulia.jl\">IJulia</a>, a collaboration between the\u00a0<a href=\"http://jupyter.org/\">Jupyter</a>\u00a0and Julia communities, provides a powerful browser-based graphical notebook interface to Julia.</p>\n<h1 id=\"a-summary-of-features\">A Summary of Features</h1>\n<ul>\n<li><a href=\"http://en.wikipedia.org/wiki/Multiple_dispatch\">Multiple dispatch</a>: providing the ability to define function behavior across many combinations of argument types</li>\n<li>Dynamic type system: types for documentation, optimization, and dispatch</li>\n<li>Good performance, approaching that of statically-compiled languages like C</li>\n<li>Built-in package manager</li>\n<li><a href=\"http://docs.julialang.org/en/stable/manual/metaprogramming/#macros\">Lisp-like macros</a>\u00a0and other\u00a0<a href=\"http://docs.julialang.org/en/stable/manual/metaprogramming/\">metaprogramming facilities</a></li>\n<li>Call Python functions: use the\u00a0<a href=\"https://github.com/stevengj/PyCall.jl\">PyCall</a>\u00a0package</li>\n<li><a href=\"http://docs.julialang.org/en/stable/manual/calling-c-and-fortran-code/\">Call C functions</a>\u00a0directly: no wrappers or special APIs</li>\n<li>Powerful shell-like capabilities for\u00a0<a href=\"http://docs.julialang.org/en/stable/manual/running-external-programs/\">managing other processes</a></li>\n<li>Designed for\u00a0<a href=\"http://docs.julialang.org/en/stable/manual/parallel-computing/\">parallelism and distributed computation</a></li>\n<li><a href=\"http://en.wikipedia.org/wiki/Coroutine\">Coroutines</a>: lightweight \u201cgreen\u201d threading</li>\n<li><a href=\"http://docs.julialang.org/en/stable/manual/types/\">User-defined types</a>\u00a0are as fast and compact as built-ins</li>\n<li>Automatic generation of efficient, specialized code for different argument types</li>\n<li>Elegant and extensible\u00a0<a href=\"http://docs.julialang.org/en/stable/manual/conversion-and-promotion/\">conversions and promotions</a>\u00a0for numeric and other types</li>\n<li>Efficient support for\u00a0<a href=\"http://en.wikipedia.org/wiki/Unicode\">Unicode</a>, including but not limited to\u00a0<a href=\"http://en.wikipedia.org/wiki/UTF-8\">UTF-8</a></li>\n<li><a href=\"https://github.com/JuliaLang/julia/blob/master/LICENSE.md\">MIT licensed</a>: free and open source</li>\n</ul>\n<h1 id=\"high-performance-jit-compiler\">High-Performance JIT Compiler</h1>\n<p>Julia\u2019s LLVM-based just-in-time (JIT) compiler combined with the language\u2019s design allow it to approach and often match the performance of C. To get a sense of the relative performance of Julia compared to other languages that can or could be used for numerical and scientific computing, we\u2019ve written a small set of micro-benchmarks in a variety of languages:\u00a0<a href=\"https://github.com/JuliaLang/Microbenchmarks/blob/master/perf.c\">C</a>,\u00a0<a href=\"https://github.com/JuliaLang/Microbenchmarks/blob/master/perf.f90\">Fortran</a>,\u00a0<a href=\"https://github.com/JuliaLang/Microbenchmarks/blob/master/perf.jl\">Julia</a>,\u00a0<a href=\"https://github.com/JuliaLang/Microbenchmarks/blob/master/perf.py\">Python</a>,\u00a0<a href=\"https://github.com/JuliaLang/Microbenchmarks/blob/master/perf.m\">Matlab/Octave</a>,\u00a0<a href=\"https://github.com/JuliaLang/Microbenchmarks/blob/master/perf.R\">R</a>,\u00a0<a href=\"https://github.com/JuliaLang/Microbenchmarks/blob/master/perf.js\">JavaScript</a>,\u00a0<a href=\"https://github.com/JuliaLang/Microbenchmarks/tree/master/java/src/main/java\">Java</a>,\u00a0<a href=\"https://github.com/JuliaLang/Microbenchmarks/blob/master/perf.lua\">Lua</a>,\u00a0<a href=\"https://github.com/JuliaLang/Microbenchmarks/blob/master/perf.nb\">Mathematica</a>. We encourage you to skim the code to get a sense for how easy or difficult it is to do numerical programming in each language.</p>\n<p><img class=\"alignnone size-full wp-image-688\" src=\"https://emolike.net/wp-content/uploads/2018/07/download.png\" alt=\"\" width=\"1162\" height=\"687\" srcset=\"https://emolike.net/wp-content/uploads/2018/07/download.png 1162w, https://emolike.net/wp-content/uploads/2018/07/download-300x177.png 300w, https://emolike.net/wp-content/uploads/2018/07/download-768x454.png 768w, https://emolike.net/wp-content/uploads/2018/07/download-1024x605.png 1024w, https://emolike.net/wp-content/uploads/2018/07/download-457x270.png 457w\" sizes=\"(max-width: 1162px) 100vw, 1162px\" /></p>\n<p><b>Figure:</b>\u00a0Benchmark times relative to C (smaller is better, C performance = 1.0). Plot created with\u00a0<a href=\"https://github.com/dcjones/Gadfly.jl\">Gadfly</a>\u00a0and\u00a0<a href=\"https://github.com/JuliaLang/IJulia.jl\">IJulia</a>\u00a0from\u00a0<a href=\"http://nbviewer.ipython.org/url/julialang.org/benchmarks/benchmarks.ipynb\">this notebook</a>. See the\u00a0<a href=\"https://julialang.org/benchmarks/\">benchmarks page</a>\u00a0for more information.</p>\n<div id=\"at_zurlpreview\">\n<h2>The Julia Language</h2>\n<h3 style=\"display: none;\">The Julia Language</h3>\n<p class=\"imgp\"><img class=\"alignnone size-full wp-image-690\" src=\"https://emolike.net/wp-content/uploads/2018/07/ijulia.png\" width=\"914\" height=\"1280\" srcset=\"https://emolike.net/wp-content/uploads/2018/07/ijulia.png 914w, https://emolike.net/wp-content/uploads/2018/07/ijulia-214x300.png 214w, https://emolike.net/wp-content/uploads/2018/07/ijulia-768x1076.png 768w, https://emolike.net/wp-content/uploads/2018/07/ijulia-731x1024.png 731w, https://emolike.net/wp-content/uploads/2018/07/ijulia-193x270.png 193w\" sizes=\"(max-width: 914px) 100vw, 914px\" /></p>\n<p class=\"imgd\">Julia is a high-level, high-performance dynamic programming language for numerical computing. It provides a sophisticated compiler, distributed parallel execution, numerical accuracy, and an extensive mathematical function library. Julia\u2019s Base library, largely written in Julia itself, also integrates mature, best-of-breed open source C and Fortran libraries for linear algebra, random number generation, signal processing, and string processing. In addition, the Julia developer community is contributing a number of external packages through Julia\u2019s built-in package manager at a rapid pace. IJulia, a collaboration between the Jupyter and Julia communities, provides a powerful browser-based graphical notebook interface to Julia.</p>\n<p class=\"imgs\">Source: <a href=\"https://julialang.org/\" target=\"_blank\" rel=\"noopener\">julialang.org/</a></p>\n</div>\n", "slug": "julia-high-performance-dynamic-programming-language-for-numerical-computing", "date": 1531398489, "cats": [13, 16]}