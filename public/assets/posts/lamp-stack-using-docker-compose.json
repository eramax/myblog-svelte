{"title": "LAMP stack using docker-compose", "content": "<h2 id=\"h1-objective\">Objective</h2>\n<p>Following this tutorial you will be able to create a LAMP environment using the Docker technology.</p>\n<h2 id=\"h2-requirements\">Requirements</h2>\n<ul>\n<li>Root permissions</li>\n<li>Basic knowledge of Docker</li>\n</ul>\n<h2 id=\"h3-difficulty\">Difficulty</h2>\n<p>MEDIUM</p>\n<h2 id=\"h4-conventions\">Conventions</h2>\n<ul>\n<li><b>#</b>\u00a0- requires given\u00a0<a href=\"https://linuxconfig.org/linux-commands\" target=\"_blank\" rel=\"noopener\">linux commands</a>\u00a0to be executed with root privileges either directly as a root user or by use of\u00a0<code>sudo</code>\u00a0command</li>\n<li><b>$</b>\u00a0- requires given\u00a0<a href=\"https://linuxconfig.org/linux-commands\" target=\"_blank\" rel=\"noopener\">linux commands</a>\u00a0to be executed as a regular non-privileged user</li>\n</ul>\n<h2 id=\"h5-introduction\">Introduction</h2>\n<p><img class=\"alignnone size-full wp-image-703\" src=\"https://emolike.net/wp-content/uploads/2018/07/docker-logo.jpg\" width=\"150\" height=\"118\" alt=\"docker_logo\" />Docker is an open source project aimed at providing software inside\u00a0<code>containers</code>. You can think of a container as a sort of \u201cpackage\u201d, an isolated environment which shares the kernel with the host machine and contains everything the application needs. All containers are built using\u00a0<code>images</code>\u00a0(the central images repository for them being\u00a0<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"nofollow noopener\">Dockerhub</a>).</p>\n<p>In this tutorial, we will see how to create a LAMP stack based on dockerized components: following the \u201cone service per container\u201d philosophy, we will assemble the environment using\u00a0<code>docker-compose</code>, a tool to orchestrate container compositions.</p>\n<h2 id=\"h6-one-service-vs-multiple-service-for-container\">One service vs multiple service for container</h2>\n<p>There are several advantages in using one service per container, instead of running multiple services in the same one. Modularity, for example, (we can reuse a container for different purposes), or a better maintainability: it&#8217;s easier to focus on a specific piece of an environment instead of considering all of them at once. If we want to respect this philosophy, we must create a container for each component of our LAMP stack: one for apache-php and one for the database. The different containers must be able to speak to each other: to easily orchestrate linked containers we will use\u00a0<code>docker-compose</code>.</p>\n<h2 id=\"h7-preliminary-steps\">Preliminary steps</h2>\n<p>Before proceeding we need to install\u00a0<code>docker</code>\u00a0and\u00a0<code>docker-compose</code>\u00a0on our system:</p>\n<pre><code data-enlighter-language=\"null\"># apt-get install docker docker-compose\r\n</code></pre>\n<p>The packages will be installed in few seconds, and the\u00a0<code>docker</code>\u00a0service will be automatically started. We can now proceed into creating a directory for our project and inside of it, another one to hold the pages that will be served by Apache. DocumentRoot would be a meaningful name for it; in this case the only page that will be served it&#8217;s\u00a0<code>index.php</code>:</p>\n<pre><code data-enlighter-language=\"null\">$ mkdir -p dockerized-lamp/DocumentRoot\r\n$ echo \"&lt;?php phpinfo(); ?&gt;\" &gt; dockerized-lamp/DocumentRoot/index.php</code></pre>\n<p>Here our code consists simply in the\u00a0<code>phpinfo</code>\u00a0function: it&#8217;s output (a page showing information about php, in case you don&#8217;t know) will be what our server will display by default. Now let&#8217;s use our favorite editor to create the\u00a0<code>docker-compose.yml</code>\u00a0file for our project.</p>\n<div class=\"moduletable\">\n<div class=\"custom\">\n<hr />\n<hr />\n</div>\n</div>\n<h4 id=\"h7-1-1-php-apache\">Php-apache</h4>\n<p>We can now start providing instruction about building and connecting our containers into the docker-compose file. This is a file which uses the\u00a0<code>yaml</code>\u00a0syntax. All definitions must be provided into the\u00a0<code>services</code>\u00a0section.</p>\n<pre><code data-enlighter-language=\"null\">version: '3'\r\nservices:\r\n    php-apache:\r\n        image: php:7.2.1-apache\r\n        ports:\r\n            - 80:80\r\n        volumes:\r\n            - ./DocumentRoot:/var/www/html\r\n        links:\r\n            - 'mariadb'</code></pre>\n<p>Let&#8217;s take a look at what we just done here. The first line we inserted into the file,\u00a0<code>version</code>, specifies what docker-compose syntax version we are going to use, in this case the version\u00a0<code>3</code>, the latest main version available. Inside the\u00a0<code>services</code>\u00a0section, we started describing our service by specifying its name,\u00a0<code>php-apache</code>\u00a0(an arbitrary name, you can use whatever you want), then the instructions for building it.</p>\n<p>The\u00a0<code>image</code>\u00a0keyword lets docker know what image we want to use to build our container: in this case I used\u00a0<code>7.2.1-apache</code>\u00a0which will provide us php 7.2.1 together with the apache web server. Need another php version? you just need to choose from the many provided in the image page on\u00a0<a href=\"https://hub.docker.com/_/php/\" target=\"_blank\" rel=\"nofollow noopener\">dockerhub</a>.</p>\n<p>The second instruction we provided is\u00a0<code>ports</code>: we are telling docker to map the port\u00a0<code>80</code>\u00a0on our host, to the port\u00a0<code>80</code>\u00a0on the container: this way will appear as we were running the web server directly on our system.</p>\n<p>We then used the\u00a0<code>volumes</code>\u00a0instruction to specify a\u00a0<code>bind mount</code>. Since during development the code changes a lot and fast, there would be no sense in putting the code directly inside a container: this way we should rebuild it every time we make some modifications. Instead, what we are going to do is to tell docker to bind-mount the\u00a0<code>DocumentRoot</code>\u00a0directory, at\u00a0<code>/var/www/html</code>\u00a0inside the container. This directory represents the main apache\u00a0<code>VirtualHost</code>\u00a0document root, therefore the code we put inside it, will be immediately available.</p>\n<p>Finally we used the\u00a0<code>link</code>\u00a0keyword specifying\u00a0<code>mariadb</code>\u00a0as its argument. This keyword it&#8217;s not needed, as it may seem, to create a connection between the two containers: even without specifying it, the\u00a0<code>mariadb</code>\u00a0service would be reachable from inside the container built for the\u00a0<code>apache-php</code>service, by using its name as an hostname. The keyword does two things: first let us optionally specify an\u00a0<code>alias</code>\u00a0we can use to reference a service in addition to its name. So, for example, by writing:</p>\n<pre><code data-enlighter-language=\"null\">link:\r\n    mariadb:database-service</code></pre>\n<p>the service could also be reached using\u00a0<code>database-service</code>. The second thing\u00a0<code>link</code>\u00a0does, is specify a dependency: in this case the\u00a0<code>php-apache</code>\u00a0service will be considered as dependent from the\u00a0<code>mariadb</code>\u00a0one, so the latter will be started before the former when building or starting the environment.</p>\n<div class=\"moduletable\">\n<div class=\"custom\">\n<hr />\n<hr />\n</div>\n</div>\n<h4 id=\"h7-1-2-install-php-extensions\">Install php extensions</h4>\n<p>The default php-apache dockerfile does not include some php extensions, like mysqli or pdo. To install them we have to build our own dockerfile, based on it. To do that, we create a directory inside of our project named php-apache (this will be our\u00a0<code>build context</code>) and inside of it, our dockerfile. Paste and save the code below as php-apache/Dockerfile:</p>\n<pre><code data-enlighter-language=\"null\">FROM php:7.2.1-apache\r\nMAINTAINER egidio docile\r\nRUN docker-php-ext-install pdo pdo_mysql mysqli</code></pre>\n<p>As you can see, with the\u00a0<code>FROM</code>\u00a0instruction, we specified that this dockerfile should be based on the default one. Then we included a\u00a0<code>RUN</code>\u00a0instruction: using the script provided in the image itself,\u00a0<code>docker-php-ext-install</code>, we include the extensions needed to use pdo and mysqli. At this point, if we want to use our custom dockerfile, we have to slightly change the php-apache section in our docker-compose.yml, this way:</p>\n<pre><code data-enlighter-language=\"null\">version: '3'\r\nservices:\r\n    php-apache:\r\n        build:\r\n            context: ./php-apache\r\n        ports:\r\n            -  80:80\r\n        volumes:\r\n            - ./DocumentRoot:/var/www/html\r\n        links:\r\n            - 'mariadb'</code></pre>\n<p>What has changed? Instead of directly specifying the remote image to use, we provided the\u00a0<code>context</code>\u00a0instruction, inside the\u00a0<code>build</code>\u00a0section, so that the dockerfile contained in the directory we created and here provided as the argument, will be automatically used. The context directory is imported by the docker daemon when building the image, so if we want to add additional files we have to put them also there.</p>\n<h4 id=\"h7-1-3-the-database-service\">The database service</h4>\n<p>A database in an essential part of a LAMP environment, it is used for persistence. In this case we are going to use\u00a0<code>mariadb</code>:</p>\n<pre><code data-enlighter-language=\"null\">mariadb:\r\n    image: mariadb:10.1\r\n    volumes:\r\n        - mariadb:/var/lib/mysql\r\n    environment:\r\n        TZ: \"Europe/Rome\"\r\n        MYSQL_ALLOW_EMPTY_PASSWORD: \"no\"\r\n        MYSQL_ROOT_PASSWORD: \"rootpwd\"\r\n        MYSQL_USER: 'testuser'\r\n        MYSQL_PASSWORD: 'testpassword'\r\n        MYSQL_DATABASE: 'testdb'</code></pre>\n<p>We already know what the\u00a0<code>image</code>\u00a0keyword is for. The same goes for the\u00a0<code>volumes</code>\u00a0instruction, except for the fact that this time we didn&#8217;t declared a\u00a0<code>bind mount</code>, instead, we referenced a\u00a0<code>named volume</code>, for persistence. It&#8217;s important to focus on the difference between the two for a moment.</p>\n<p>As said before, a\u00a0<code>bind mount</code>\u00a0is a quick way to mount an host directory inside a container, so that the files contained in said directory become accessible from inside the restricted environment: to specify a bind mount, the\u00a0<code>short syntax</code>\u00a0is:</p>\n<pre><code data-enlighter-language=\"null\">&lt;host_path&gt;:&lt;mountpoint_inside_the_container&gt;\r\n</code></pre>\n<p>The host path can be a relative (to the docker-compose file) or an absolute path, while the mountpoint inside the container must be specified in absolute form.</p>\n<p>A\u00a0<code>named volume</code>\u00a0is something different: it is a proper\u00a0<code>docker volume</code>\u00a0used for persistence, and it is generally to be preferred over a bind mount, because it doesn&#8217;t depend on the host file structure (one of the many advantages of containers it&#8217;s their portability). The syntax to use to reference a\u00a0<code>named volume</code>\u00a0inside a service definition is:</p>\n<pre><code data-enlighter-language=\"null\">&lt;volume_name&gt;:&lt;mountpoint_inside_container&gt;\r\n</code></pre>\n<p>A\u00a0<code>named volume</code>\u00a0life cycle is independent from that of a container which uses it, and must be declared in the\u00a0<code>volumes</code>\u00a0section of the docker-compose file, as we will see in a moment.</p>\n<p>Back to the definition of the service now. The last keyword we used is\u00a0<code>environment</code>: it lets us set some environment variables which will influence the behavior of the service. First we used\u00a0<code>TZ</code>\u00a0to specify our database timezone: in this case I used \u201cEurope/Rome\u201d. The names of the other variables say everything about their purpose: by using them we set important details as the name of the default database to be created (testdb), the user to be created and its password. We also set the root user password and decided to don&#8217;t allow empty passwords.</p>\n<div class=\"moduletable\">\n<div class=\"custom\">\n<hr />\n<hr />\n</div>\n</div>\n<h4 id=\"h7-1-4-the-volumes-section\">The volumes section</h4>\n<p>In this section we must declare the\u00a0<code>named volume</code>\u00a0we referenced from the\u00a0<code>mariadb</code>\u00a0server definition:</p>\n<pre><code data-enlighter-language=\"null\">volumes:\r\n    mariadb:</code></pre>\n<p>At the end, this is how our file will look in its entirety:</p>\n<pre><code data-enlighter-language=\"null\">version: '3'\r\nservices:\r\n    php-apache:\r\n        image: php:7.2.1-apache\r\n        ports:\r\n            - 80:80\r\n        volumes:\r\n            - ./DocumentRoot:/var/www/html:z\r\n        links:\r\n            - 'mariadb'\r\n\r\n    mariadb:\r\n        image: mariadb:10.1\r\n        volumes:\r\n            - mariadb:/var/lib/mysql\r\n        environment:\r\n            TZ: \"Europe/Rome\"\r\n            MYSQL_ALLOW_EMPTY_PASSWORD: \"no\"\r\n            MYSQL_ROOT_PASSWORD: \"rootpwd\"\r\n            MYSQL_USER: 'testuser'\r\n            MYSQL_PASSWORD: 'testpassword'\r\n            MYSQL_DATABASE: 'testdb'\r\n\r\nvolumes:\r\n    mariadb:</code></pre>\n<p>It&#8217;s really important to respect indentation for the file to be interpreted correctly.</p>\n<h2 id=\"h8-let-s-build-our-environment\">Let&#8217;s build our environment</h2>\n<p>Once we specified all instructions for our services, we can use the\u00a0<code>docker-compose up</code>\u00a0command to build them. The command must be executed inside the same directory where the\u00a0<code>docker-compose.yml</code>\u00a0file is located:</p>\n<pre><code data-enlighter-language=\"null\"># docker-compose up\r\n</code></pre>\n<p>Few minutes and we will be ready to go. At the end if everything went well, by navigating to\u00a0<code>localhost</code>\u00a0on our host, we shall see the output of the php script we placed inside\u00a0<code>DocumentRoot</code>:</p>\n<p><img class=\"alignnone size-full wp-image-704\" src=\"https://emolike.net/wp-content/uploads/2018/07/phpinfo-output.png\" width=\"730\" height=\"366\" alt=\"phpinfo-output\" srcset=\"https://emolike.net/wp-content/uploads/2018/07/phpinfo-output.png 730w, https://emolike.net/wp-content/uploads/2018/07/phpinfo-output-300x150.png 300w, https://emolike.net/wp-content/uploads/2018/07/phpinfo-output-539x270.png 539w\" sizes=\"(max-width: 730px) 100vw, 730px\" /></p>\n<p>Our lamp environment is now ready to be used.</p>\n<h2 id=\"h9-closing-thoughts\">Closing thoughts</h2>\n<p>We have seen how to create a basic\u00a0<code>LAMP</code>\u00a0environment, using docker and orchestrating containers and services with\u00a0<code>docker-compose</code>. The setup we used it&#8217;s focused on development, and can be further expanded and tweaked to match different needs: Docker documentation it&#8217;s a very well written source you can consult to expand your docker knowledge. Don&#8217;t hesitate to leave a comment for whatever doubts or questions you have.</p>\n<div id=\"at_zurlpreview\">\n<p class=\"imgp\"><img data-src=\"\" /></p>\n<p class=\"imgd\">Tutorial about creating a LAMP stack using docker-compose</p>\n<p class=\"imgs\">Source: <a href=\"https://linuxconfig.org/how-to-create-a-docker-based-lamp-stack-using-docker-compose-on-ubuntu-18-04-bionic-beaver-linux\" target=\"_blank\" rel=\"noopener\">linuxconfig.org/how-to-create-a-docker-based-lamp-stack-using-docker-compose-on-ubuntu-18-04-bionic-beaver-linux</a></p>\n</div>\n", "slug": "lamp-stack-using-docker-compose", "date": 1532352113, "cats": [1, 10, 14]}