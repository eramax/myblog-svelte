{"title": "Lighter than Lightweight: How We Built the Same App Twice with Preact and Glimmer.js", "content": "<div class=\"resourceParagraph section\">\n<div class=\"resource-text-section\">\n<div class=\"resource-paragraph rich-text\">\n<p>The beauty of the web is that there is no \u201cinstall\u201d step. Someone, somewhere taps a link to your site, and moments later it appears instantly in front of them.</p>\n<p>At least, that\u2019s the idea\u2014but not all devices and networks are created equally. Sites that feel fast on a desktop computer with broadband can feel downright slow on a mobile phone with spotty 3G service.</p>\n<p>So how do you build sites that stay fast no matter what? To help us better understand, we built a prototype application with two popular JavaScript libraries,\u00a0<a href=\"https://preactjs.com/\" target=\"_blank\" rel=\"nofollow noopener\">Preact</a>\u00a0and\u00a0<a href=\"http://glimmerjs.com/\" target=\"_blank\" rel=\"nofollow noopener\">Glimmer.js</a>, that embody different philosophies of how to maximize web performance.</p>\n<h2>Emerging performance trends</h2>\n<p>Over the past few years, there has been excitement in the web development community about the idea of using lightweight libraries\u2014those that prioritize small file size above all else\u2014to build websites that load instantly. Advocates of this approach explain that every byte of JavaScript is a performance liability\u2014and many popular frameworks should be considered \u201ctoo big\u201d even before you\u2019ve written a single line of app code. Detractors of this philosophy argue that prioritizing file size over robustness stops paying dividends\u2014and can become a liability\u2014as an application grows. They argue that skimping on abstractions and infrastructure in the beginning just means pushing additional complexity into the app itself.</p>\n<p>One exciting trend to emerge recently has been the idea of\u00a0<a href=\"https://tomdale.net/2017/09/compilers-are-the-new-frameworks/\" target=\"_blank\" rel=\"nofollow noopener\">using compilers to \u201cbend the curve\u201d of tradeoffs between file size and robustness</a>. A compiler can analyze your entire application and, theoretically, produce optimized output and assets that include only what you need.</p>\n<p>This approach has its skeptics, too, who argue that compilers will have trouble beating a hand-tuned lightweight library. If the compiled output is still larger than the lightweight library, the argument goes, any performance gains will be wiped out.</p>\n<p>Unfortunately, it\u2019s very difficult to test these competing philosophies in the real world. If you want to compare how performance changes as complexity grows, how do you test that without building the same app twice? If you\u2019re really motivated to answer this question, you could try to build the same app twice. But is that feasible? Well, that\u2019s exactly what we did here at LinkedIn.</p>\n<h2>The need for feed</h2>\n<p>This project first started with the goal of building a prototype that optimized for page load time at all costs, to help us calibrate what \u201ctheoretical maximum\u201d performance looked like.</p>\n<p>Since the first thing members see when they visit LinkedIn is the feed, we thought a reimplementation of this page would be the ideal prototype for experiments around initial load time. It\u2019s also a complex page with many different features, which was important for verifying that performance improvements held as the application grew.</p>\n</div>\n</div>\n</div>\n<div class=\"resourceImageBlock section\">\n<div class=\"component-anchor-container\"><a class=\"component-anchor\" name=\"post_par_resourceimageblock\"></a></div>\n<ul class=\"resource-image-block single\">\n<li class=\"resource-image\"><img class=\"alignnone size-full wp-image-1002\" src=\"https://emolike.net/wp-content/uploads/2018/10/preactglimmer2.jpg\" width=\"700\" height=\"374\" alt=\"preactglimmer2\" srcset=\"https://emolike.net/wp-content/uploads/2018/10/preactglimmer2.jpg 700w, https://emolike.net/wp-content/uploads/2018/10/preactglimmer2-300x160.jpg 300w, https://emolike.net/wp-content/uploads/2018/10/preactglimmer2-505x270.jpg 505w\" sizes=\"(max-width: 700px) 100vw, 700px\" /></li>\n</ul>\n</div>\n<div class=\"resourceParagraph section\">\n<div class=\"component-anchor-container\"><a class=\"component-anchor\" name=\"post_par_resourceparagraph_1969725901\"></a></div>\n<div class=\"resource-text-section\">\n<div class=\"resource-paragraph rich-text\">\n<p><i>The LinkedIn Feed</i></p>\n<p>Some of the engineers on our team believed Preact would help us build the fastest site possible. Preact is an open source JavaScript library that implements a subset of the\u00a0<a href=\"https://reactjs.org/\" target=\"_blank\" rel=\"nofollow noopener\">React</a>\u00a0component API. Many developers in the JavaScript community consider Preact to be the gold standard for building fast sites, and for good reason. What sets Preact apart is its truly remarkable file size. While the standard build of React is about 30kb minified and gzipped, Preact is just 3kb\u201410x smaller\u2014for very similar functionality.</p>\n<p>Other engineers on our team believed that Glimmer.js would yield a faster experience for the app we were building. Like Preact, Glimmer.js is an open source JavaScript library for building UI components for the web. It is built on the same rendering engine as\u00a0<a href=\"https://www.emberjs.com/\" target=\"_blank\" rel=\"nofollow noopener\">Ember.js</a>, but unlike Ember, provides just the UI layer\u2014no routing, data loading, or other features. Even though Glimmer is about 20kb larger than Preact, it compiles an application\u2019s HTML templates into\u00a0<a href=\"https://engineering.linkedin.com/blog/2017/12/the-glimmer-binary-experience\" target=\"_blank\" rel=\"noopener\">compact bytecode</a>\u00a0that gets executed in the browser. Preact, like React, relies on using JavaScript to build Virtual DOM. Glimmer\u2019s bytecode, besides being smaller than the equivalent\u00a0<a href=\"https://jsx.github.io/\" target=\"_blank\" rel=\"nofollow noopener\">JSX</a>\u00a0output, does not require a parse step. The engineers advocating for Glimmer believed that, given an app with a real-world feature set, the faster template downloading and parsing speed would make up for any difference in library size.</p>\n<p>LinkedIn is a data-driven company and we wanted to let data help us answer this question. Instead of choosing between Preact and Glimmer.js, we instead built our prototype application in two different \u201cflavors.\u201d Then, we measured how their performance stacked up in the real world.</p>\n</div>\n</div>\n</div>\n<div class=\"resourceImageBlock section\">\n<div class=\"component-anchor-container\"><a class=\"component-anchor\" name=\"post_par_resourceimageblock_1778660636\"></a></div>\n<ul class=\"resource-image-block single\">\n<li class=\"resource-image\"><img class=\"alignnone size-full wp-image-1003\" src=\"https://emolike.net/wp-content/uploads/2018/10/preactglimmer3.jpg\" width=\"700\" height=\"463\" alt=\"preactglimmer3\" srcset=\"https://emolike.net/wp-content/uploads/2018/10/preactglimmer3.jpg 700w, https://emolike.net/wp-content/uploads/2018/10/preactglimmer3-300x198.jpg 300w, https://emolike.net/wp-content/uploads/2018/10/preactglimmer3-408x270.jpg 408w\" sizes=\"(max-width: 700px) 100vw, 700px\" /></li>\n</ul>\n</div>\n<div class=\"resourceParagraph section\">\n<div class=\"component-anchor-container\"><a class=\"component-anchor\" name=\"post_par_resourceparagraph_1580440323\"></a></div>\n<div class=\"resource-text-section\">\n<div class=\"resource-paragraph rich-text\">\n<p><i>Our prototype: a reimplementation of the LinkedIn feed in Preact and Glimmer.js \u201cflavors\u201d<br />\n</i></p>\n<h2>The tech stack</h2>\n<p>Given the experimental nature of this project, we took the opportunity to test-drive several other exciting frontend technologies to see if they would help us achieve our load time goals.</p>\n<p>In addition to Preact and Glimmer.js, our prototype used:</p>\n<ul>\n<li><a href=\"http://www.typescriptlang.org/\" target=\"_blank\" rel=\"nofollow noopener\">TypeScript</a>, a typed superset of JavaScript</li>\n<li><a href=\"https://webpack.js.org/\" target=\"_blank\" rel=\"nofollow noopener\">webpack</a>, a compiler and runtime for JavaScript to produce optimized static assets</li>\n<li><a href=\"http://css-blocks.com/\" target=\"_blank\" rel=\"nofollow noopener\">CSS Blocks</a>, a component-oriented, highly-optimizable subset of CSS</li>\n</ul>\n<p>To reduce the cost of building the same app twice, we shared as much implementation as possible between the Preact and Glimmer flavors. All of our code went into a single repository that we organized into packages. Components for each flavor went into either the glimmer-ui or preact-ui package. Things like routing, data fetching, performance monitoring, and CSS were shared across both flavors.</p>\n</div>\n</div>\n</div>\n<div class=\"resourceImageBlock section\">\n<div class=\"component-anchor-container\"><a class=\"component-anchor\" name=\"post_par_resourceimageblock_1472227923\"></a></div>\n<ul class=\"resource-image-block single\">\n<li class=\"resource-image\"><img class=\"alignnone size-full wp-image-1004\" src=\"https://emolike.net/wp-content/uploads/2018/10/preactglimmer4.jpg\" width=\"500\" height=\"184\" alt=\"preactglimmer4\" srcset=\"https://emolike.net/wp-content/uploads/2018/10/preactglimmer4.jpg 500w, https://emolike.net/wp-content/uploads/2018/10/preactglimmer4-300x110.jpg 300w\" sizes=\"(max-width: 500px) 100vw, 500px\" /></li>\n</ul>\n</div>\n<div class=\"resourceParagraph section\">\n<div class=\"component-anchor-container\"><a class=\"component-anchor\" name=\"post_par_resourceparagraph_1601532073\"></a></div>\n<div class=\"resource-text-section\">\n<div class=\"resource-paragraph rich-text\">\n<p>When it came time to deploy, we used webpack to create optimized Glimmer and Preact builds, with any code unused by a particular flavor left out of its bundle.</p>\n<h2>Measuring up</h2>\n<p>Page load is a continuum, not a single point in time. While it\u2019s tempting to pick a single number to compare \u201cpage load time,\u201d we wanted to capture and compare the holistic experience of each flavor.</p>\n<p>Chrome exposes two\u00a0<a href=\"https://developers.google.com/web/fundamentals/performance/user-centric-performance-metrics\" target=\"_blank\" rel=\"nofollow noopener\">performance metrics that better approximate the user experience</a>:</p>\n<ol>\n<li><b>First Meaningful Paint</b>, which approximates when the page\u2019s primary content first appears.</li>\n<li><b>Time to Interactive</b>, which measures how long it takes for the main thread to become idle enough to reliably respond to user interaction.</li>\n</ol>\n<p>When available, we reported these metrics using LinkedIn\u2019s\u00a0<a href=\"https://engineering.linkedin.com/blog/2017/06/site-speed-monitoring-in-a-b-testing-and-feature-ramp-up\" target=\"_blank\" rel=\"noopener\">Real User Monitoring</a>(RUM) infrastructure. For browsers that don\u2019t expose these metrics, we implemented approximations that measured when the HTML page had finished loading and when the application had finished starting up, indicating the page was fully interactive.</p>\n<h2>The results</h2>\n<p>Once both prototypes were feature-complete, benchmarking using\u00a0<a href=\"https://www.webpagetest.org/\" target=\"_blank\" rel=\"nofollow noopener\">WebPagetest</a>indicated that both flavors performed neck-and-neck, even on a smartphone with a simulated 3G network. However, experience has taught us that synthetic benchmarks don\u2019t always tell the full story. We know the only way to be confident in how these prototypes behaved for members was to test in the real world.</p>\n<p>We also created two variants of each flavor: one that used server-side rendering (SSR) to generate initial HTML on the server, and another that performed all rendering on the client in JavaScript. We hypothesized that client-side rendering may be faster in some cases by parallelizing the work of booting the app and fetching API data.</p>\n<p>We ran the four variations of the prototype for one week to collect performance metrics from real members, which we fed into our\u00a0<a href=\"https://engineering.linkedin.com/blog/topic/rum\" target=\"_blank\" rel=\"noopener\">Real User Monitoring (RUM)</a>system. At the end of the week, we saw the following results:</p>\n</div>\n</div>\n</div>\n<div class=\"resourceTable section\">\n<div class=\"component-anchor-container\"><a class=\"component-anchor\" name=\"post_par_resourcetable\"></a></div>\n<div class=\"resource-table-section header-row\">\n<table>\n<tbody>\n<tr>\n<td>Variant</td>\n<td>First Meaningful Paint (90th %ile)</td>\n<td>Render/Rehydrate Complete (90th %ile)</td>\n<td>Time to Interactive (90th %ile)</td>\n</tr>\n<tr>\n<td>Glimmer SSR</td>\n<td>2533</td>\n<td>4112</td>\n<td>6323</td>\n</tr>\n<tr>\n<td>Glimmer CSR</td>\n<td>4029</td>\n<td>4000</td>\n<td>5709</td>\n</tr>\n<tr>\n<td>Preact SSR</td>\n<td>2938</td>\n<td>4263</td>\n<td>5749</td>\n</tr>\n<tr>\n<td>Preact CSR</td>\n<td>4096</td>\n<td>4043</td>\n<td>6257</td>\n</tr>\n</tbody>\n</table>\n</div>\n</div>\n<div class=\"resourceParagraph section\">\n<div class=\"component-anchor-container\"><a class=\"component-anchor\" name=\"post_par_resourceparagraph_90015706\"></a></div>\n<div class=\"resource-text-section\">\n<div class=\"resource-paragraph rich-text\">\n<p><i>Time in milliseconds; lower is better. SSR = Server-side rendered, CSR = Client-side rendered. Render time measured in CSR mode, rehydration time measured in SSR mode.</i></p>\n<p>Both flavors performed very well. The SSR variants in particular showed dramatic improvement in First Meaningful Paint, reducing the time before a member sees useful content by over one second compared to the CSR variants.</p>\n<p>Based on our test, Glimmer.js seemed to slightly outperform Preact at achieving First Meaningful Paint and Rehydrating/Rendering the page, in both the server-side rendered and client-side rendered variants. Preact seemed to slightly outperform Glimmer.js in Time to Interactive (TTI), which measures how quickly the CPU becomes idle after page load. Performing a root cause analysis of this difference has proven difficult because it is much more variable than the other metrics, and is sensitive to confounding factors such as ads and members beginning to interact with the page.</p>\n<p>Either way, overall load time performance is very close\u2014within hundreds of milliseconds\u2014between the two flavors.</p>\n<h2>So what does it mean?</h2>\n<p>Ultimately, both Preact and Glimmer.js are fantastic tools for building fast, modern web applications. Both technologies allowed us to build an app that beat the initial load time of the control version. The difference in performance between the two flavors was so small as to be effectively imperceptible.</p>\n<p>Both libraries offer their own unique benefits. Our team noted that Preact\u2019s use of JSX offered productivity benefits, particularly thanks to integration with TypeScript. On the other hand, Glimmer\u2019s unique architecture will allow it to take advantage of WebAssembly. This opens up a tantalizing avenue of exploration for improving load time even more in the future.</p>\n<p>One takeaway from our experiment is that file size, while important, is not the whole story. Many people use library size as a proxy for how fast their application will load. Based on our findings, apps built with a larger library can load as fast or faster than those built with a smaller library, by amortizing the file size difference via savings in other areas.</p>\n<p>It\u2019s important to reiterate that we focused only on initial load times. There are other important performance metrics, such as responsiveness to interaction, that were out of scope for this experiment.</p>\n<p>We are grateful for the rare opportunity to conduct this test, where we were given the time and resources to build two versions of the same app with the same team. We are also grateful to be in the unique position of having had maintainers from both Preact and Glimmer.js on the team, helping guide each implementation.</p>\n<p>For us, the outcome of this experiment is particularly exciting because Glimmer.js shares a rendering engine with Ember.js, which is used to build LinkedIn today. We are in the process of taking the learnings from our prototype and contributing them back to Ember.js, so that we can improve the performance of our existing app and bring our learnings to the rest of the community.</p>\n<p>Source :\u00a0<a href=\"https://engineering.linkedin.com/blog/2018/03/how-we-built-the-same-app-twice-with-preact-and-glimmerjs\">https://engineering.linkedin.com/blog/2018/03/how-we-built-the-same-app-twice-with-preact-and-glimmerjs</a></p>\n</div>\n</div>\n</div>\n", "slug": "lighter-than-lightweight-how-we-built-the-same-app-twice-with-preact-and-glimmer-js", "date": 1539181496, "cats": [36, 18, 29]}