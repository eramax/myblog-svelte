{"title": "Rule Your Microservices with an API Gateway: Part I", "content": "<header class=\"post-header\"></header>\n<section class=\"post-content\">Traditionally web applications have been implemented so that one application includes all of the business logic. These\u00a0<a href=\"https://en.wikipedia.org/wiki/Monolithic_application\">monolithic applications</a>\u00a0are very easy to build and start with smaller codebases and they are relatively easy to test. Also, IDEs have good support for monolith applications and they are faster to develop in the beginning.Monolithic applications can be successful, but increasingly people are feeling frustrated with them. Every change requires the whole application to be rebuilt and deployed. Also, Monolith applications can only be scaled horizontally. So, you end up running multiple instances of the entire monolith application on multiple servers behind a load balancer.</p>\n<h2 id=\"explodeyourmonolithintomicroservices\">Explode Your Monolith into Microservices</h2>\n<p>Using the\u00a0<a href=\"https://martinfowler.com/articles/microservices.html\">microservice</a>\u00a0architectural paradigm allows you to develop a single application as a set of loosely coupled, collaborating services. Each service implements a set of narrowly, related functions and communicates with lightweight mechanisms, such as a HTTP resource API. So instead of having a codebase that handles all of the entities, now you have different services that are being deployed and scaled independently from each other.</p>\n<p><img class=\"alignnone size-full wp-image-153\" src=\"https://emolike.net/wp-content/uploads/2018/03/microservices_1_small-2.jpg\" alt=\"alt\" width=\"1280\" height=\"720\" srcset=\"https://emolike.net/wp-content/uploads/2018/03/microservices_1_small-2.jpg 1280w, https://emolike.net/wp-content/uploads/2018/03/microservices_1_small-2-300x169.jpg 300w, https://emolike.net/wp-content/uploads/2018/03/microservices_1_small-2-768x432.jpg 768w, https://emolike.net/wp-content/uploads/2018/03/microservices_1_small-2-1024x576.jpg 1024w, https://emolike.net/wp-content/uploads/2018/03/microservices_1_small-2-200x113.jpg 200w\" sizes=\"(max-width: 1280px) 100vw, 1280px\" /></p>\n<p>Microservices are relatively small and easier for a developer to understand. They provide better architecture for large applications and better isolation for scalability and damage control. However, they contain more moving parts and are harder to test. Developers must also pay attention to complexity, security, network latency and connectivity issues that are coming with microservices. Also debugging is harder when dealing with loosely coupled services. Microservices are not answer to every use case. Sometimes monolith can be better solution.</p>\n<p>The best foundation for running a microservices application architecture is application containers. Containers encapsulate a lightweight runtime environment for the application, presenting an isolated and consistent software environment. Containers provide faster initialization and execution and they are easy to scale up and down. However, containers themselves do not make sense without an orchestrator service such as\u00a0<a href=\"https://www.kontena.io/\">Kontena</a>,\u00a0<a href=\"https://www.docker.com/\">Docker Swarm</a>\u00a0or\u00a0<a href=\"https://kubernetes.io/\">Kubernetes</a>\u00a0which delivers the desired application functionality.</p>\n<p>With microservices architecture most of the API calls are\u00a0<a href=\"https://blog.appdynamics.com/devops/visualizing-and-tracking-your-microservices/\">internal</a>. Thus, running microservices requires a good\u00a0<a href=\"https://en.wikipedia.org/wiki/Overlay_network\">overlay network</a>,\u00a0<a href=\"https://en.wikipedia.org/wiki/Service_discovery\">service discovery</a>\u00a0and a\u00a0<a href=\"https://en.wikipedia.org/wiki/Load_balancing_(computing)\">load balancer</a>. Typically, these are provided by the orchestrator service or by using and configuring external tools or add-ons. For example,\u00a0<a href=\"https://www.kontena.io/\">Kontena</a>provides these out of the box.</p>\n<h2 id=\"rulemicroserviceswithanapigateway\">Rule Microservices with an API Gateway</h2>\n<p>When having lots of services, controlling the total flow can become hard. A Service might be updated and the address of the service could change. This requires changes to other related services as well. Also, dealing with different kinds of clients that have different kinds of requirements can be problematic. Systems might need also centralized authentication and security. The solution to these problems is to use API gateways.</p>\n<p>An API gateway provides a single, unified API entry point across one or more internal APIs. Rather than invoking different services, clients simply talk to the gateway. In other words, it insulates the clients from how the application is partitioned into microservices. It also adds an additional layer of protection by providing protection from attack vectors.</p>\n<p><img class=\"alignnone size-full wp-image-154\" src=\"https://emolike.net/wp-content/uploads/2018/03/microservices_1.jpg\" alt=\"\" width=\"1280\" height=\"720\" srcset=\"https://emolike.net/wp-content/uploads/2018/03/microservices_1.jpg 1280w, https://emolike.net/wp-content/uploads/2018/03/microservices_1-300x169.jpg 300w, https://emolike.net/wp-content/uploads/2018/03/microservices_1-768x432.jpg 768w, https://emolike.net/wp-content/uploads/2018/03/microservices_1-1024x576.jpg 1024w, https://emolike.net/wp-content/uploads/2018/03/microservices_1-200x113.jpg 200w\" sizes=\"(max-width: 1280px) 100vw, 1280px\" /></p>\n<p>The API gateway enables support for mixing communication protocols and decreases microservice complexity by providing authorization using API tokens, access control enforcement, and rate limiting.</p>\n<p>The API gateway is responsible for request routing, composition, and protocol translation. All requests from clients first go through the API Gateway. It then routes requests to the appropriate microservice.</p>\n<p>However, the API gateway increases the complexity of the system by adding yet another moving part that must be managed. Also, it increases response time due to the additional network hop through the API gateway.</p>\n<h2 id=\"buildingmicroservicesrunningmicroservices\">Building Microservices != Running Microservices</h2>\n<p>Building and running microservices are different things. Building microservices is the architectural pattern that requires that services are designed to be independent and isolated. Without a good design there is a risk that users end up building a monolith that is divided into multiple tightly coupled services. When services are ready and tested, users definitely wants to run and monitor them.</p>\n<p>Running and monitoring microservices require the right tools. Without the right tools it can become time-consuming and maintaining the microservice platform itself can take more time than maintaining the application itself.</p>\n<p>In the next part of this blog post series, we will show how to setup, run and monitor an API gateway and microservices very easily with\u00a0<a href=\"https://www.kontena.io/\">Kontena</a>.</p>\n<h2 id=\"aboutkontena\">About Kontena</h2>\n<p>Want to learn about real life use cases of Kontena, case studies, best practices, tips &amp; tricks? Need some help with your project? Want to contribute to a project or help other people? Join the\u00a0<a href=\"https://forum.kontena.io/\">Kontena Forum</a>\u00a0to discuss more about the\u00a0<a href=\"https://www.kontena.io/platform#overview\">Kontena Platform</a>, chat with other happy developers on our\u00a0<a href=\"https://slack.kontena.io/\">Slack</a>\u00a0discussion channel or meet people in person at one of our\u00a0<a href=\"https://www.meetup.com/pro/kontena/\">Meetup groups</a>\u00a0located all around the world.</p>\n<p>source:\u00a0https://blog.kontena.io/rule-your-microservices-with-an-api-gateway/</p>\n</section>\n", "slug": "rule-your-microservices-with-an-api-gateway-part-i", "date": 1520963865, "cats": [7, 14]}