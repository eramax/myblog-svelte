{"title": "The Mediator Pattern In .NET Core", "content": "<p>A couple of years back, I had to help out on a project that was built entirely using the \u201cMediator Pattern\u201d. Or more specifically, built entirely using the\u00a0<a href=\"https://github.com/jbogard/MediatR\" target=\"_blank\" rel=\"noopener noreferrer\">MediatR</a>\u00a0library. There were all these presentations about the \u201ctheory\u201d behind the Mediator Pattern and how it was a real new way of thinking. I couldn\u2019t help but think\u2026 We\u2019ve been doing this for years. Except we just call it good programming\u2026 Infact I had my own pattern which we\u2019ll look into in Part 2 that I called the \u201cIEnumerable Pattern\u201d which achieved the same thing.</p>\n<p>But it\u2019s taken all these years to finally write it all down. So here it is. Here\u2019s the Mediator Pattern in C# (Or more specifically, .NET Core).</p>\n<h3>The Mediator Pattern \u201cDefinition\u201d</h3>\n<p>The Mediator Pattern actually dates all the way back to 1994 in the famous book \u201c<i><b>Design Patterns: Elements of Reusable Object-Oriented Software\u201d.\u00a0</b></i>But I feel like it\u2019s only really sprung up again lately due to a slew of libraries trying to implement the pattern.</p>\n<p>In a nutshell, the definition (as stolen from Wikipedia) is :</p>\n<p><em>The essence of the Mediator Pattern is to \u201cdefine an object that encapsulates how a set of objects interact\u201d. It promotes loose coupling by keeping objects from referring to each other explicitly, and it allows their interaction to be varied independently.\u00a0<sup id=\"cite_ref-3\" class=\"reference\"></sup>Client classes can use the mediator to send messages to other clients, and can receive messages from other clients via an event on the mediator class.</em></p>\n<p>So let\u2019s break it down a little into two bullet points that we will refer back to later.</p>\n<ul>\n<li>It\u2019s an object that encapsulates how objects interact. So it can obviously handle passing on \u201cmessages\u201d between objects.</li>\n<li>It promotes loose coupling by not having objects refer to each other, but instead to the mediator. So they pass the messages to the mediator, who will pass it on to the right person.</li>\n</ul>\n<p>That\u2019s honestly it.</p>\n<p>And when you think about just those two bullet points in isolation. It sounds awfully like a message hub of sorts right? That\u2019s because\u2026 It actually kinda is. It\u2019s like a message hub in code. When you send a message through a typical message hub, you don\u2019t know who is receiving that message, you just know that the hub knows and it will sort it out for you.</p>\n<h3>In Visual Form</h3>\n<p>If we break this out into visual form using my (very limited) lucidchart skills. It looks a bit like this :</p>\n<p><img class=\"alignnone size-full wp-image-1428\" src=\"https://emolike.net/wp-content/uploads/2019/05/MediatorPattern.png\" width=\"836\" height=\"528\" alt=\"\" title=\"MediatorPattern\" srcset=\"https://emolike.net/wp-content/uploads/2019/05/MediatorPattern.png 836w, https://emolike.net/wp-content/uploads/2019/05/MediatorPattern-300x189.png 300w, https://emolike.net/wp-content/uploads/2019/05/MediatorPattern-768x485.png 768w\" sizes=\"(max-width: 836px) 100vw, 836px\" /></p>\n<p>This is probably a simplified version of it because a Mediator Pattern does allow two way communication, it\u2019s not just a one way broadcast, but I think this is the model we are going to try and use going forward in our examples.</p>\n<p>Again, looking at it this way, it\u2019s hard not to see the comparisons to messaging systems. But on the other hand, it\u2019s hard not to also feel like this could very quickly turn into one of those \u201csuper\u201d classes where sure, MyService doesn\u2019t reference every handler\u2026 But the Mediator does. But there are ways to handle that which we will go into later.</p>\n<h3>Why?</h3>\n<p>And finally, the \u201cWhy?\u201d. Why is this even a thing?</p>\n<p>Well if we take the diagram above, if we had MyService calling other handlers directly (For example notifying them about an action), then as we add handlers, MyService has to start referencing them all even if it doesn\u2019t care about the result. For example, our service might start looking like this :</p>\n<pre><code data-enlighter-language=\"null\">class MyService\r\n{\r\n    private readonly Handler1 _handler1;\r\n    private readonly Handler2 _handler2;\r\n    private readonly Handler3 _handler3;\r\n            \r\n \r\n    public MyService(Handler1 handler1, Handler2 handler2, Handler3 handler3)\r\n    {\r\n        _handler1 = handler1;\r\n        _handler2 = handler2;\r\n        _handler3 = handler3;\r\n    }\r\n \r\n    public void DoSomething()\r\n    {\r\n        //Do something here. \r\n        //And do some more work\r\n \r\n        //And then notify our handlers. \r\n        _handler1.Notify(new HandlerArgs());\r\n        _handler2.Notify(new HandlerArgs());\r\n        _handler3.Notify(new HandlerArgs());\r\n    }\r\n}</code></pre>\n<p>So what happens when we add more handlers? Or remove handlers? Our service keeps changing when in reality it doesn\u2019t really care who gets notified.</p>\n<p>Using a Mediator Pattern, it may instead end up looking like :</p>\n<pre><code data-enlighter-language=\"null\">class MyService\r\n{\r\n    private HandlerMediator _handlerMediator;\r\n \r\n    public MyService(HandlerMediator handlerMediator)\r\n    {\r\n        _handlerMediator = handlerMediator;\r\n    }\r\n \r\n    public void DoSomething()\r\n    {\r\n        //Do something here. \r\n        //And do some more work\r\n \r\n        //And then notify our handlers. \r\n        _handlerMediator.Notify(new HandlerArgs());\r\n    }\r\n}\r\n \r\n \r\nclass HandlerMediator\r\n{\r\n    private readonly Handler1 _handler1;\r\n    private readonly Handler2 _handler2;\r\n    private readonly Handler3 _handler3;\r\n \r\n \r\n    public HandlerMediator(Handler1 handler1, Handler2 handler2, Handler3 handler3)\r\n    {\r\n        _handler1 = handler1;\r\n        _handler2 = handler2;\r\n        _handler3 = handler3;\r\n    }\r\n \r\n    public void Notify(HandlerArgs handlerArgs)\r\n    {\r\n        _handler1.Notify(handlerArgs);\r\n        _handler2.Notify(handlerArgs);\r\n        _handler3.Notify(handlerArgs);\r\n    }\r\n}</code></pre>\n<p>So there\u2019s the bonus that as handlers change, get added or removed, the service itself doesn\u2019t change. But there is also a bit of a downer that we are maybe shifting the load to the Mediator, it\u2019s job is now to manage the handlers and how they get notified. But this makes sense right! To have a class whose sole job is to notify clients should be able to change depending on how those clients need to be notified. And our service which really doesn\u2019t care about the implementation details of those handlers can get on with it\u2019s work.</p>\n<p>In saying that, later on we will see how we use DI to really help us ease the load from both classes and yet still stick to heart of the Mediator Pattern.</p>\n<h3>MediatR Library</h3>\n<p>The\u00a0<a href=\"https://github.com/jbogard/MediatR\" target=\"_blank\" rel=\"noopener noreferrer\">MediatR</a>\u00a0library describes itself as \u201cSimple, unambitious mediator implementation in .NET\u201d. In particular, I like the word \u201cUnambitious\u201d being used. It\u2019s somewhat refreshing in a world of Hacker News posts that claim to be releasing a library that will change the way we write code forever. You may also recognize the author of MediatR as\u00a0<a href=\"https://twitter.com/jbogard\" target=\"_blank\" rel=\"noopener noreferrer\">Jimmy Bogard</a>\u00a0who also maintains AutoMapper!</p>\n<p>MediatR is essentially a library that allows in process messaging \u2013 which in turn allows you to follow the Mediator Pattern! Easy! Let\u2019s get started</p>\n<h3>Installing MediatR</h3>\n<p>The first thing we need to do is install the MediatR nuget package. So from your package manager console run :</p>\n<pre><code data-enlighter-language=\"null\">Install-Package MediatR\r\n</code></pre>\n<p>We also need to install a package that allows us to use the inbuilt IOC container in .NET Core to our advantage (We\u2019ll see more of that shortly). So also install the following package :</p>\n<div id=\"crayon-5cf1860532289170064325\" class=\"crayon-syntax crayon-theme-vs2012 crayon-font-consolas crayon-os-pc print-yes notranslate\" data-settings=\" minimize scroll-mouseover\">\n<div class=\"crayon-plain-wrap\">\n<pre><code data-enlighter-language=\"null\">Install-Package MediatR.Extensions.Microsoft.DependencyInjection\r\n</code></pre>\n<p>Finally we open up our startup.cs file. In our ConfigureServices method, we need to add in a call to register all of MediatR\u2019s dependencies.</p>\n<div id=\"crayon-5cf186053228b348762644\" class=\"crayon-syntax crayon-theme-vs2012 crayon-font-consolas crayon-os-pc print-yes notranslate\" data-settings=\" minimize scroll-mouseover\">\n<div class=\"crayon-plain-wrap\">\n<pre><code data-enlighter-language=\"null\">public void ConfigureServices(IServiceCollection services)\r\n{\r\n    services.AddMediatR(Assembly.GetExecutingAssembly());\r\n    //Other injected services. \r\n}</code></pre>\n<h3>Creating Our Handlers</h3>\n<p>The first thing to note is that MediatR can be either do \u201csend and receive\u201d type messages, or it can do a \u201cbroadcast\u201d type message. Taking our example from our previous article in the series, we are doing a more broadcast style of message (And a pretty simple one at that). Let\u2019s just stick with that for now.</p>\n<p>In our original example, we weren\u2019t passing through any information to our handlers, but in reality we are likely passing through some data. Basically a message if we think about traditional messaging systems. Let\u2019s go ahead and just create a blank object that inherits from\u00a0<span id=\"crayon-5cf186053228e319094190\" class=\"crayon-syntax crayon-syntax-inline  crayon-theme-vs2012 crayon-theme-vs2012-inline crayon-font-consolas\"><span class=\"crayon-pre crayon-code\"><span class=\"crayon-v\">INotification</span></span></span>\u00a0 (An inbuilt type of MediatR).</p>\n<pre><code data-enlighter-language=\"null\">public class NotificationMessage : INotification\r\n{\r\n    public string NotifyText { get; set; }\r\n}</code></pre>\n<p>Next we need handlers for the messages. That\u2019s easy too, we just inherit from\u00a0<span id=\"crayon-5cf1860532292239442691\" class=\"crayon-syntax crayon-syntax-inline  crayon-theme-vs2012 crayon-theme-vs2012-inline crayon-font-consolas\"><span class=\"crayon-pre crayon-code\"><span class=\"crayon-v\">INotificationHandler</span></span></span>\u00a0 and go from there!</p>\n<div id=\"crayon-5cf1860532294800027151\" class=\"crayon-syntax crayon-theme-vs2012 crayon-font-consolas crayon-os-pc print-yes notranslate\" data-settings=\" minimize scroll-mouseover\">\n<div class=\"crayon-plain-wrap\">\n<pre><code data-enlighter-language=\"null\">public class Notifier1 : INotificationHandler&lt;NotificationMessage&gt;\r\n{\r\n    public Task Handle(NotificationMessage notification, CancellationToken cancellationToken)\r\n    {\r\n        Debug.WriteLine($\"Debugging from Notifier 1. Message  : {notification.NotifyText} \");\r\n        return Task.CompletedTask;\r\n    }\r\n}\r\n \r\npublic class Notifier2 : INotificationHandler&lt;NotificationMessage&gt;\r\n{\r\n    public Task Handle(NotificationMessage notification, CancellationToken cancellationToken)\r\n    {\r\n        Debug.WriteLine($\"Debugging from Notifier 2. Message  : {notification.NotifyText} \");\r\n        return Task.CompletedTask;\r\n    }\r\n}</code></pre>\n<p>Super simple! We also don\u2019t need to register these handlers anywhere, the initial line we added to our ConfigureServices method means that MediatR finds all handlers within the assembly and registers them correctly.</p>\n<h3>Creating Our Mediator Service</h3>\n<p>Now here\u2019s the thing. We *can* just inject in the inbuilt IMediator interface everywhere and publish messages directly. Personally I\u2019m not a huge fan because it\u2019s basically telling everywhere \u201cby the way, we use MediatR\u201d. I prefer to abstract things away a little bit.</p>\n<p>If we take our Mediator Service from the previous article, let\u2019s just modify it a bit. Instead let\u2019s build it like so :</p>\n<pre><code data-enlighter-language=\"null\">public interface INotifierMediatorService\r\n{\r\n    void Notify(string notifyText);\r\n}\r\n \r\npublic class NotifierMediatorService : INotifierMediatorService\r\n{\r\n    private readonly IMediator _mediator;\r\n \r\n    public NotifierMediatorService(IMediator mediator)\r\n    {\r\n        _mediator = mediator;\r\n    }\r\n \r\n    public void Notify(string notifyText)\r\n    {\r\n        _mediator.Publish(new NotificationMessage { NotifyText = notifyText });\r\n    }\r\n}</code></pre>\n<p>So we have a NotifierService that still uses the IMediator class under the hood, but it means if we ever swap out libraries or change how we do notifications, only this class changes.</p>\n<p>Because we have created a new service, we do need to remember to add the following line to our ConfigureServices method in our startup.cs file :</p>\n<pre><code data-enlighter-language=\"null\">services.AddTransient&lt;INotifierMediatorService, NotifierMediatorService&gt;();\r\n</code></pre>\n<h3>Using Our Notifier Mediator Service</h3>\n<p>Let\u2019s use a super simple controller to run things. Again this is basically taken from Part 2 in this series and just modified a tiny bit to work with passing through notify text.</p>\n<pre><code data-enlighter-language=\"null\">public class HomeController : ControllerBase\r\n{\r\n    private readonly INotifierMediatorService _notifierMediatorService;\r\n \r\n    public HomeController(INotifierMediatorService notifierMediatorService)\r\n    {\r\n        _notifierMediatorService = notifierMediatorService;\r\n    }\r\n \r\n    [HttpGet(\"\")]\r\n    public ActionResult&lt;string&gt; NotifyAll()\r\n    {\r\n        _notifierMediatorService.Notify(\"This is a test notification\");\r\n        return \"Completed\";\r\n    }\r\n}</code></pre>\n<p>Running all of this and opening up our debug panel we can see :</p>\n<div id=\"crayon-5cf186053229d973426052\" class=\"crayon-syntax crayon-theme-vs2012 crayon-font-consolas crayon-os-pc print-yes notranslate\" data-settings=\" minimize scroll-mouseover\">\n<div class=\"crayon-plain-wrap\">\n<pre><code data-enlighter-language=\"null\">Debugging from Notifier 1. Message  : This is a test notification \r\nDebugging from Notifier 2. Message  : This is a test notification</code></pre>\n<p>Woo! Literally a 5 minute job to set up a completely in memory messaging system!</p>\n<h3>Final Thoughts On The Mediator Pattern</h3>\n<p>As we made our way through these 3 posts, it\u2019s probably morphed a bit from the \u201cMediator Pattern\u201d to \u201cIn Process Messaging\u201d.\u00a0But going back to our key bullet points from Part 1 :</p>\n<ul>\n<li>It\u2019s an object that encapsulates how objects interact. So it can obviously handle passing on \u201cmessages\u201d between objects.</li>\n<li>It promotes loose coupling by not having objects refer to each other, but instead to the mediator. So they pass the messages to the mediator, who will pass it on to the right person.</li>\n</ul>\n<p>We can see that In Process Messaging is actually just an \u201cimplementation\u201d of the mediator pattern. As long as we are promoting loose coupling through a \u201cmediator\u201d class that can pass data back and forth so that the caller doesn\u2019t need to know how things are being handled (By whom and by how many handlers), then we can say we are implementing the Mediator Pattern.</p>\n<p>Source : <a href=\"https://dotnetcoretutorials.com/2019/04/30/the-mediator-pattern-part-3-mediatr-library/\">https://dotnetcoretutorials.com/2019/04/30/the-mediator-pattern-part-3-mediatr-library/\u00a0</a></p>\n<blockquote class=\"wp-embedded-content\" data-secret=\"eJ5AJiMoX5\"><p><a href=\"https://dotnetcoretutorials.com/2019/04/30/the-mediator-pattern-in-net-core-part-1-whats-a-mediator/\">The Mediator Pattern In .NET Core - Part 1 - What&#8217;s A Mediator?</a></p></blockquote>\n<p><iframe title=\"\u201cThe Mediator Pattern In .NET Core - Part 1 - What&#8217;s A Mediator?\u201d &#8212; .NET Core Tutorials\" class=\"wp-embedded-content\" sandbox=\"allow-scripts\" security=\"restricted\" style=\"position: absolute; clip: rect(1px, 1px, 1px, 1px);\" src=\"https://dotnetcoretutorials.com/2019/04/30/the-mediator-pattern-in-net-core-part-1-whats-a-mediator/embed/#?secret=eJ5AJiMoX5\" data-secret=\"eJ5AJiMoX5\" width=\"600\" height=\"338\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\"></iframe></p>\n</div>\n<div class=\"crayon-main\"></div>\n</div>\n</div>\n<div class=\"crayon-main\"></div>\n</div>\n</div>\n<div class=\"crayon-main\"></div>\n</div>\n</div>\n<div class=\"crayon-main\"></div>\n</div>\n", "slug": "the-mediator-pattern-in-net-core", "date": 1559337749, "cats": [12, 13, 17, 16, 5, 14]}