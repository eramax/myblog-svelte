{"title": "What is the Difference Between a DTO and a POCO?", "content": "<p>First off, I\u2019m not the authority on DTOs, POCOs, object oriented architecture, or really anything now that I stop to think about it.\u00a0 However, I do use a DTO / POCO centric architecture whenever I can and there\u2019s at least one former client of mine who is now saddled with an entity class named DevicePoco (there was already a Device entity object that followed the Active Record pattern, otherwise I would never have named an object XXXPoco). When my client saw the new object with the crazy name in their BAL, their first reaction was of course to ask \u201cWhat the heck is a POCO?\u201d\u00a0 Not too long ago I was at a Visual Studio User Group meeting where the question of POCOs and how they are different from DTOs came up.\u00a0 The presenter, who quite honestly is a much better developer than me, stated confidently that POCOs and DTOs are the same thing.\u00a0 I immediately clamped both hands over my mouth to keep from screaming \u201cThey are not!\u201d.\u00a0 So, there seems to be a lack of good information in the .Net community about what these objects are.\u00a0 I\u2019m going to try and clarify the issue.</p>\n<p><strong><span style=\"font-size: medium;\">What is a Data Transfer Object (DTO)?</span></strong></p>\n<p>Normally this is where I would say Wikipedia defines a DTO as&#8230;\u00a0 Unfortunately, the current Wikipedia definition is pretty awful except for the line:</p>\n<p><span style=\"color: #000080;\"><em>\u201cThe difference between Data Transfer Objects and\u00a0</em></span><a href=\"http://en.wikipedia.org/wiki/Business_object_%28computer_science%29\"><span style=\"color: #000080;\"><em>Business Objects</em></span></a><span style=\"color: #000080;\"><em>\u00a0or\u00a0</em></span><a href=\"http://en.wikipedia.org/wiki/Data_Access_Object\"><span style=\"color: #000080;\"><em>Data Access Objects</em></span></a><span style=\"color: #000080;\"><em>\u00a0is that a DTO does not have any behaviour except for storage and retrieval of its own data (</em></span><a href=\"http://en.wikipedia.org/wiki/Method_%28computer_science%29\"><span style=\"color: #000080;\"><em>accessors</em></span></a><span style=\"color: #000080;\"><em>\u00a0and\u00a0</em></span><a href=\"http://en.wikipedia.org/wiki/Mutator_method\"><span style=\"color: #000080;\"><em>mutators</em></span></a><span style=\"color: #000080;\"><em>).\u201d</em></span></p>\n<p>That\u2019s the key concept.\u00a0 A DTO stores data.\u00a0 It has no methods (behaviors) other than accessors and mutators which are just used to get and set data.\u00a0 Why make an object that simple? Because they make a great, lightweight, strongly typed data container when you want to move data from your DAL to your BAL or between the umpteen layers in your n-tier architecture.\u00a0 Below is the code for the PersonDTO that I\u2019ve been using in many of my recent posts. You\u2019ll notice that it really does nothing except store data.</p>\n<pre><code data-enlighter-language=\"csharp\">public class PersonDTO : DTOBase\r\n\r\n{\r\n\r\n    public Guid PersonGuid { get;set; }\r\n\r\n    public int PersonId { get; set; }\r\n\r\n    public DateTime UtcCreated { get; set; }\r\n\r\n    public DateTime UtcModified { get; set; }\r\n\r\n    public string Password { get; set; }\r\n\r\n    public string Name { get; set; }\r\n\r\n    public string Nickname { get; set; }\r\n\r\n    public string PhoneMobile { get; set; }\r\n\r\n    public string PhoneHome { get; set; }\r\n\r\n    public string Email { get; set; }\r\n\r\n    public string ImAddress { get; set; }\r\n\r\n    public int ImType { get; set; }\r\n\r\n    public int TimeZoneId { get; set; }\r\n\r\n    public int LanguageId { get; set; }\r\n\r\n    public string City { get; set; }\r\n\r\n    public string State { get; set; }\r\n\r\n    public int ZipCode { get; set; }\r\n\r\n \r\n\r\n \r\n\r\n    // Constructor\r\n\r\n    // No parameters and all value types are intialized to the\r\n\r\n    // null values defined in CommonBase.\r\n\r\n    public PersonDTO()\r\n\r\n    {        \r\n\r\n        PersonGuid = Guid_NullValue;\r\n\r\n        PersonId = Int_NullValue;\r\n\r\n        UtcCreated = DateTime_NullValue;\r\n\r\n        UtcModified = DateTime_NullValue; \r\n\r\n        Name = String_NullValue;\r\n\r\n        Nickname = String_NullValue;\r\n\r\n        PhoneMobile = String_NullValue;\r\n\r\n        PhoneHome = String_NullValue;\r\n\r\n        Email = String_NullValue;\r\n\r\n        ImAddress = String_NullValue;\r\n\r\n        ImType = Int_NullValue;\r\n\r\n        TimeZoneId = Int_NullValue;\r\n\r\n        LanguageId = Int_NullValue;\r\n\r\n        City = String_NullValue;\r\n\r\n        State = String_NullValue;\r\n\r\n        ZipCode = Int_NullValue;\r\n\r\n        IsNew = true;\r\n\r\n    }\r\n\r\n}</code></pre>\n<p>So, to sum up, a DTO is just a collection of properties (or data members).\u00a0 It has no validation, no business logic, no logic of any kind.\u00a0 It\u2019s just a simple, lightweight data container used for moving data between layers.</p>\n<p><strong><span style=\"font-size: medium;\">So What\u2019s a POCO?</span></strong></p>\n<p>A POCO is not a DTO.\u00a0 POCO stands for Plain Old CLR Object, or Plain Old C# Object.\u00a0 It\u2019s basically the .Net version of a POJO, Plain Old Java Object.\u00a0 A POCO is your Business Object.\u00a0 It has data, validation, and any other business logic that you want to put in there.\u00a0 But there\u2019s one thing a POCO does not have, and that\u2019s what makes it a POCO.\u00a0 POCOs do not have persistence methods.\u00a0 If you have a POCO of type Person, you can\u2019t have a Person.GetPersonById() method, or a Person.Save() method.\u00a0 POCOs contain only data and domain logic, no persistence logic of any kind.\u00a0 The term you\u2019ll hear for this concept is Persistence Ignorance (PI).\u00a0 POCOs are Persistence Ignorant.</p>\n<p>Below is the code for my BAL.Person class which is a POCO.\u00a0 You\u2019ll notice that it contains no persistence logic of any kind, just data and validation methods.\u00a0 You\u2019ll also notice that I don\u2019t recreate a bunch of accessors and mutators for my person data.\u00a0 That would clutter up my Person class, plus they would be redundant since they\u2019ve already been defined in PersonDTO.\u00a0 Instead I just have a single property named Data that is of type PersonDTO.\u00a0 This approach makes getting and saving a person really easy.\u00a0 When getting a person, I just get a PersonDTO from my DAL and then set person.Data = personDTO.\u00a0 When saving, my save methods all take a PersonDTO as a parameter so I can just use my person.Data property for that as well.</p>\n<pre><code data-enlighter-language=\"csharp\">public class Person : BALBase\r\n\r\n{\r\n\r\n        // Data\r\n\r\n        // This property exists for all BAL objects, and it is\r\n\r\n        // set to the DTO type for this entity.  This is the\r\n\r\n        // mechanism that we use to implement \"has a\" inheritance\r\n\r\n        // instead of \"is a\" inheritance.\r\n\r\n        public PersonDTO Data { get; set; }\r\n\r\n \r\n\r\n \r\n\r\n        // Person - default constructor\r\n\r\n        public Person() {this.Data = new PersonDTO();}\r\n\r\n\r\n        // Person - takes a DTO\r\n\r\n        public Person(PersonDTO dto) {this.Data = dto;}\r\n\r\n \r\n\r\n \r\n\r\n\r\n          // Validate\r\n        public override List&lt;ValidationError&gt; Validate()\r\n\r\n        {\r\n\r\n            // Call all validation functions\r\n\r\n            Val_Name();\r\n\r\n            Val_Email();\r\n\r\n            Val_Password();\r\n\r\n            Val_TimeZone();\r\n\r\n            Val_City();\r\n\r\n            Val_State();\r\n\r\n            Val_ZipCode();\r\n\r\n            Val_ImType();\r\n\r\n \r\n\r\n            // If the ValidationErrors list is empty then\r\n\r\n            // we passed validation.\r\n\r\n            return this.ValidationErrors;\r\n\r\n        }\r\n\r\n \r\n\r\n \r\n\r\n        // Validation Methods:\r\n\r\n        // There are only 2 requirements on validation methods.\r\n\r\n        //  - They must handle adding a Validation Error to the\r\n\r\n        //    ValidationErrors list if they find an error.\r\n\r\n        //  - You must manually add a call to all validation methods\r\n\r\n        //    to the Validate() function.\r\n\r\n        //  When creating a new ValidationError object, remember\r\n\r\n        //  that the first parameter is the exact name of the field\r\n\r\n        //  that has the bad value, and the error message should\r\n\r\n        //  not contain the field name, but instead the &lt;FieldName&gt;\r\n\r\n        //  tag, which will be replaced by the UI or consuming app.\r\n\r\n \r\n\r\n        // Val_Name\r\n\r\n        public bool Val_Name()\r\n\r\n        {\r\n\r\n            // Name required\r\n\r\n            if (this.Data.Name == DTOBase.String_NullValue)\r\n\r\n            {\r\n\r\n                this.ValidationErrors.Add(new ValidationError(\"Person.Name\", \"&lt;FieldName&gt; is required\"));\r\n\r\n                return false;\r\n\r\n            }\r\n\r\n            else\r\n\r\n            {\r\n\r\n                return true;\r\n\r\n            }\r\n\r\n        }\r\n\r\n \r\n\r\n        // You get the idea.  I\u2019m leaving out the rest of the validation code\r\n\r\n        // so you don\u2019t go blind reading the same lines over and over.\r\n\r\n}</code></pre>\n<p> </p>\n<p>No persistence logic there, just data and validation logic.\u00a0 So you\u2019re probably thinking, if the persistence logic doesn\u2019t go in my entity class, then where does it go?\u00a0 The answer is, another class.\u00a0 POCOs must be hydrated by some other class that encapsulates the persistence logic for that entity, like a repository or a data controller.\u00a0 I typically use a repository.\u00a0 For this example I used a PersonRepository class that encapsulates the logic for getting a new person object, getting a personDTO from the DAL, and then setting person.Data = personDTO. Same with the save.\u00a0 My PersonRepository class has a SavePerson() method that takes a full person object then passes its person.Data value to the DAL to be persisted.\u00a0 Code for getting and setting a person entity in my UI looks like this:</p>\n<pre><code data-enlighter-language=\"csharp\">hydrate from db:\r\n\r\nPerson person = PersonRepository.GetPersonByEmail(email);\r\n\r\n \r\n\r\nsave to db:\r\n\r\nPersonRepository.SavePerson(ref person, true);</code></pre>\n<p><span style=\"font-size: medium;\"><strong>Why Would I Ever Want to Do This?</strong></span></p>\n<p>The next question you might ask is What\u2019s the point?\u00a0 Why should I use these patterns instead of just using DataTables and putting all my persistence logic in my entity objects?\u00a0 That answer is a little tougher.\u00a0 I prefer a POCO / Repository / DTO architecture, but it\u2019s not the one right way to design an application.\u00a0 I think the benefits are that it is a very clean and easy to maintain architecture.\u00a0 It provides separation of business logic and persistence logic, which is more in line with the Single Responsibility Principle.\u00a0 Using POCOs with DTOs and a well designed DAL is just about the best performing architecture you can build, see my series on\u00a0<a href=\"http://rlacovara.blogspot.com/2009/02/high-performance-data-access-layer.html\">High Performance DAL Architecture</a>. But, I think most .Net developers will be driven to use POCOs and repositories (but not DTOs) by ORMs.\u00a0 Entity Framework, nHibernate, and a lot of the ORMs out there require or assume a POCO type architecture. In fact, Entity Framework has introduced an IPOCO interface which I\u2019m having trouble finding documentation on but it sounds like something good. Also, if you want to get into Domain Driven Design, you\u2019ve got to embrace the POCO.\u00a0 In his excellent book Applying Domain-Driven Design and Patterns, Jimmy Nilsson even has a section titled \u201cPOCO as a Lifestyle\u201d.</p>\n<p>So, in conclusion, learn to love the POCO, and make sure you don\u2019t spread any misinformation about it being the same thing as a DTO.\u00a0 DTOs are simple data containers used for moving data between the layers of an application.\u00a0 POCOs are full fledged business objects with the one requirement that they are Persistence Ignorant (no get or save methods).\u00a0 Lastly, if you haven\u2019t checked out Jimmy Nilsson\u2019s book yet, pick it up from your local university stacks.\u00a0 It has examples in C# and it\u2019s a great read.</p>\n<p>Source :\u00a0<a href=\"https://rlacovara.blogspot.com/2009/03/what-is-difference-between-dto-and-poco.html\">https://rlacovara.blogspot.com/2009/03/what-is-difference-between-dto-and-poco.html</a></p>\n<p> </p>\n", "slug": "what-is-the-difference-between-a-dto-and-a-poco", "date": 1543184694, "cats": [0, 13, 17, 15]}