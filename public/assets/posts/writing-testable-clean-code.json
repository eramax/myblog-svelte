{"title": "Writing Testable & Clean Code", "content": "<p id=\"6fcb\" class=\"graf graf--p graf-after--figure\">Many developers have a hate relationship with testing. However, I believe the main cause of that is code that is highly-coupled and difficult to test.</p>\n<p id=\"f783\" class=\"graf graf--p graf-after--p\">This post states some principles and guidelines that can help you write easily-testable code, which is not only easier to test but also more flexible and maintainable, due to its better modularity. Here at Feedzai, we try to follow these principles and guidelines in order to have better code quality, increased test coverage and confidence in the products we deliver.</p>\n<p id=\"0267\" class=\"graf graf--p graf-after--p\">This article mostly serves as an introduction to these concepts. If you want to understand these concepts better, you may want to do some additional research. The article explores the SOLID principles, the Law of Demeter, some other guidelines and ends with a small example that illustrates some of the aspects explored here.</p>\n<h3 id=\"3fc1\" class=\"graf graf--h3 graf-after--p\">SOLID design principles</h3>\n<p id=\"06cb\" class=\"graf graf--p graf-after--h3\">One of the most well-known collections of principles in the software engineering industry are the SOLID principles, documented by Robert C. Martin (also known as Uncle Bob).</p>\n<p id=\"b2c6\" class=\"graf graf--p graf-after--p\">This collection of principles can help your code to be more modular and to have increased testability. Let\u2019s go deeper into each of these principles:</p>\n<h4 id=\"236f\" class=\"graf graf--h4 graf-after--p\">Single Responsibility Principle (SRP)</h4>\n<blockquote id=\"8f76\" class=\"graf graf--blockquote graf-after--h4\"><p>Each software module should only have one reason to change.</p></blockquote>\n<p id=\"290c\" class=\"graf graf--p graf-after--blockquote\">So, what does that mean? Let\u2019s take an example:</p>\n<p id=\"ef48\" class=\"graf graf--p graf-after--p\">Imagine that you write a program that calls an external REST API endpoint, does some kind of processing with the received data and writes it to a CSV file. A na\u00efve approach might be to have everything in the same class. However, this class has multiple reasons to change:</p>\n<ul class=\"postList\">\n<li id=\"bebe\" class=\"graf graf--li graf-after--p\">You might want to change the API call to a different provider or change it to read from a different source, such as a file.</li>\n<li id=\"c11b\" class=\"graf graf--li graf-after--li\">The processing that you are doing might need to be changed.</li>\n<li id=\"8eeb\" class=\"graf graf--li graf-after--li\">You may want to write the results to a different output, maybe a different file format.</li>\n<li id=\"a577\" class=\"graf graf--li graf-after--li\">In addition, you might want to be able to have multiple types of inputs and outputs that can be interchanged in runtime based on some kind of configuration or input.</li>\n</ul>\n<p id=\"bfa3\" class=\"graf graf--p graf-after--li\">For these reasons, you should break your application down into multiple classes and interfaces. Here\u2019s an example:</p>\n<pre><code data-enlighter-language=\"null\">interface DataInput {\r\n  Data get();\r\n}\r\n\r\ninterface DataOutput {\r\n  void write(ProcessingResult result);\r\n}\r\n\r\ninterface DataProcessingStrategy {\r\n  ProcessingResult process(Data data);\r\n}\r\n\r\nclass DataProcessor {\r\n  DataProcessor(DataInput dataInput, DataOutput dataOutput, DataProcessingStrategy strategy) {\r\n    ...\r\n  }\r\n  process() {\r\n    Data data = this.dataInput.get();\r\n    ProcessingResult result = this.strategy.process(data);\r\n    this.dataOutput.output(result);\r\n  }\r\n}</code></pre>\n<section class=\"section section--body section--first\">\n<div class=\"section-content\">\n<div class=\"section-inner sectionLayout--insetColumn\">\n<p id=\"ba65\" class=\"graf graf--p graf-after--figure\">This principle can be applied at both class and method levels (and to some extent at the package level, but\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod\">Robert Martin has specific principles for that</a>).</p>\n<p id=\"83b0\" class=\"graf graf--p graf-after--p\">However, you should be careful not to overdo it. The Single Responsibility Principle does not state that a module should only do one thing. It states it should have one and only one reason to change. For more information about this, please read\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://blog.cleancoder.com/uncle-bob/2014/05/08/SingleReponsibilityPrinciple.html\">this blog post from Robert Martin</a>.</p>\n<h4 id=\"2eea\" class=\"graf graf--h4 graf-after--p\">Open/Closed Principle (OCP)</h4>\n<blockquote id=\"567f\" class=\"graf graf--blockquote graf-after--h4\"><p>Your classes should be open for extension but closed to modifications.</p></blockquote>\n<p id=\"3ea2\" class=\"graf graf--p graf-after--blockquote\">This means that your design should allow the addition of new features with minimal change to the existing code. This can be achieved by coding against abstractions instead of concrete implementations, as well as through the use of some design patterns such as\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://sourcemaking.com/design_patterns/decorator\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://sourcemaking.com/design_patterns/decorator\">Decorator</a>,\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://sourcemaking.com/design_patterns/visitor\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://sourcemaking.com/design_patterns/visitor\">Visitor</a>\u00a0and\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://sourcemaking.com/design_patterns/strategy\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://sourcemaking.com/design_patterns/strategy\">Strategy</a>. Following the Single Responsibility Principle also helps with that, as you will have things segregated.</p>\n<p id=\"c4d9\" class=\"graf graf--p graf-after--p\">The best way to think about this principle is to think about a plugin architecture. In such a scenario, plugins are developed to add behaviour to a system without changing any of its code.</p>\n<p id=\"82cd\" class=\"graf graf--p graf-after--p\">Another smaller but more concrete example is Java\u2019s Collections.sort method. It can sort any type of class that implements the Comparable interface without modifying the sort method for each new class. If you instead had a sort method with a switch statement with a case for every type you wanted to compare, you would have to modify it every time you needed to compare a new type.</p>\n<p id=\"a82d\" class=\"graf graf--p graf-after--p\">For more information on this principle, you can read\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://blog.cleancoder.com/uncle-bob/2014/05/12/TheOpenClosedPrinciple.html\">Robert Martin\u2019s blog post about it</a>.</p>\n<h4 id=\"9716\" class=\"graf graf--h4 graf-after--p\">Liskov Substitution Principle (LSP)</h4>\n<blockquote id=\"15f1\" class=\"graf graf--blockquote graf-after--h4\"><p>Objects of a superclass shall be replaceable with objects of its subclasses without breaking the application.</p></blockquote>\n<p id=\"9da5\" class=\"graf graf--p graf-after--blockquote\">A good example for this principle is the s<a class=\"markup--anchor markup--p-anchor\" href=\"https://en.wikipedia.org/wiki/Square-rectangle_problem\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://en.wikipedia.org/wiki/Square-rectangle_problem\">quare-rectangle problem</a>: you might be tempted to have a\u00a0<em class=\"markup--em markup--p-em\">Shape</em>\u00a0interface, a\u00a0<em class=\"markup--em markup--p-em\">Rectangle</em>\u00a0that implements that, and a\u00a0<em class=\"markup--em markup--p-em\">Square</em>\u00a0which extends it but guarantees that both height and width are always the same. This might look good at first glance. However, this example breaks the Liskov Substitution Principle because even though the programmatic API is the same, its preconditions and postconditions are not. If you have a class or method which accepts a Rectangle, you might not be able to simply pass in a Square in its place because the code might be assuming that the height and width can be changed independently. For the user of the interface, the implementation should not matter.</p>\n<p id=\"a7e8\" class=\"graf graf--p graf-after--p\">Another common example of breaking this principle is having implementations with methods that throw\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://docs.oracle.com/javase/8/docs/api/?java/lang/UnsupportedOperationException.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://docs.oracle.com/javase/8/docs/api/?java/lang/UnsupportedOperationException.html\">UnsupportedOperationException</a>, which indicate that a certain operation is not supported in some specific implementations.</p>\n<h4 id=\"6550\" class=\"graf graf--h4 graf-after--p\">Interface Segregation Principle (ISP)</h4>\n<blockquote id=\"0f6b\" class=\"graf graf--blockquote graf-after--h4\"><p>No client should be forced to depend on methods it does not use.</p></blockquote>\n<p id=\"6ce1\" class=\"graf graf--p graf-after--blockquote\">Large interfaces should be split into smaller and more specific ones so that clients will only have to know about the methods that are of interest to them<em class=\"markup--em markup--p-em\">.</em></p>\n<p id=\"e2c5\" class=\"graf graf--p graf-after--p\">Following this principle helps to keep your system decoupled and makes it easier not to break the Liskov Substitution Principle.</p>\n<p id=\"5962\" class=\"graf graf--p graf-after--p\">For example, if you are creating an interface for a multi-functional printer, instead of having a single\u00a0<em class=\"markup--em markup--p-em\">MultiFunctionalPrinter\u00a0</em>interface with a print() and a scan() method, you should instead have two interfaces:\u00a0<em class=\"markup--em markup--p-em\">Printer</em>\u00a0and\u00a0<em class=\"markup--em markup--p-em\">Scanner</em>, each with the respective method. That way, if a client only needs the print() method, you can provide it with a simple printer without having to change any of the application code, as the client was not dependent on the scan aspects of the\u00a0<em class=\"markup--em markup--p-em\">MultiFunctionalPrinter.</em></p>\n<h4 id=\"4135\" class=\"graf graf--h4 graf-after--p\">Dependency Inversion Principle (DIP)</h4>\n<blockquote id=\"7b7a\" class=\"graf graf--blockquote graf-after--h4\"><p>High-level modules should not depend on low-level modules; both should depend on abstractions.</p></blockquote>\n<blockquote id=\"bed8\" class=\"graf graf--blockquote graf-after--blockquote\"><p>Abstractions should not depend on details. Details should depend upon abstractions.</p></blockquote>\n<p id=\"4fdd\" class=\"graf graf--p graf-after--blockquote\">Following this principle allows you to easily replace certain implementations with compatible ones which follow the same interface. This is very useful for testing as it allows you to replace real implementations with\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://testing.googleblog.com/2013/07/testing-on-toilet-know-your-test-doubles.html\">test doubles</a>. It also allows you to better react to changing requirements.</p>\n<p id=\"5634\" class=\"graf graf--p graf-after--p\">The following diagram shows how the example presented in the Single Responsibility Principle section also follows the Dependency Inversion Principle. You can see that both high-level and low-level modules depend on abstractions.</p>\n<figure id=\"d26c\" class=\"graf graf--figure graf-after--p\">\n<div class=\"aspectRatioPlaceholder is-locked\">\n<div class=\"aspectRatioPlaceholder-fill\"></div>\n<div class=\"progressiveMedia js-progressiveMedia graf-image is-canvasLoaded is-imageLoaded\" data-image-id=\"1*gs90qqPjYleH7xc4d30RyQ.png\" data-width=\"1083\" data-height=\"936\" data-action=\"zoom\" data-action-value=\"1*gs90qqPjYleH7xc4d30RyQ.png\" data-scroll=\"native\"><canvas class=\"progressiveMedia-canvas js-progressiveMedia-canvas\" width=\"75\" height=\"63\"></canvas><img class=\"alignnone size-full wp-image-1327\" src=\"https://emolike.net/wp-content/uploads/2019/05/1gs90qqPjYleH7xc4d30RyQ.png\" width=\"1083\" height=\"936\" srcset=\"https://emolike.net/wp-content/uploads/2019/05/1gs90qqPjYleH7xc4d30RyQ.png 1083w, https://emolike.net/wp-content/uploads/2019/05/1gs90qqPjYleH7xc4d30RyQ-300x259.png 300w, https://emolike.net/wp-content/uploads/2019/05/1gs90qqPjYleH7xc4d30RyQ-768x664.png 768w, https://emolike.net/wp-content/uploads/2019/05/1gs90qqPjYleH7xc4d30RyQ-1024x885.png 1024w\" sizes=\"(max-width: 1083px) 100vw, 1083px\" /></div>\n</div><figcaption class=\"imageCaption\">Example of the usage of the Dependency Inversion Principle</figcaption></figure>\n<p id=\"8c9d\" class=\"graf graf--p graf-after--figure graf--trailing\">For more information on the topic of abstractions, you may read\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://medium.com/feedzaitech/the-power-of-abstraction-11e825d2ed85\" target=\"_blank\" rel=\"noopener noreferrer\" data-href=\"https://medium.com/feedzaitech/the-power-of-abstraction-11e825d2ed85\">this post by Gabriel Candal on the Feedzai TechBlog</a>. \ud83d\udcaa</p>\n</div>\n</div>\n</section>\n<section class=\"section section--body\">\n<div class=\"section-divider\">\n<hr class=\"section-divider\" />\n</div>\n<div class=\"section-content\">\n<div class=\"section-inner sectionLayout--insetColumn\">\n<h3 id=\"b50a\" class=\"graf graf--h3 graf--leading\">Law of Demeter\u00a0(LoD)</h3>\n<p id=\"eaa1\" class=\"graf graf--p graf-after--h3\">Another \u201claw\u201d which is useful for keeping the code decoupled and testable is the Law of Demeter. This principle states the following:</p>\n<blockquote id=\"2542\" class=\"graf graf--blockquote graf-after--p\"><p>Each unit should have only limited knowledge about other units: only units \u201cclosely\u201d related to the current unit.<br />\nEach unit should only talk to its friends; don\u2019t talk to strangers.<br />\nOnly talk to your immediate friends.</p></blockquote>\n<p id=\"385c\" class=\"graf graf--p graf-after--blockquote\">What this basically means is that you should not obtain dependencies through your dependencies. You should not do things like\u00a0<em class=\"markup--em markup--p-em\">this.getA().getB().doSomething().\u00a0</em>If you need dependency B, it should be provided to your class through its constructor or as a method argument.</p>\n<p id=\"e67a\" class=\"graf graf--p graf-after--p\">Breaking this principle makes the code highly-coupled to implementation details and substantially less reusable. It also makes tests much harder to write because it requires you to mock or create instances of not only the explicit collaborators of the class under test but also all the implicit chain of collaborators required by it.</p>\n<p id=\"0431\" class=\"graf graf--p graf-after--p graf--trailing\">You can find more information about this principle on\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://testing.googleblog.com/2008/07/breaking-law-of-demeter-is-like-looking.html\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://testing.googleblog.com/2008/07/breaking-law-of-demeter-is-like-looking.html\">this blog post by Mi\u0161ko Hevery</a>.</p>\n</div>\n</div>\n</section>\n<section class=\"section section--body\">\n<div class=\"section-divider\">\n<hr class=\"section-divider\" />\n</div>\n<div class=\"section-content\">\n<div class=\"section-inner sectionLayout--insetColumn\">\n<h3 id=\"fc4a\" class=\"graf graf--h3 graf--leading\">Some Guidelines</h3>\n<p id=\"d91d\" class=\"graf graf--p graf-after--h3\">Besides these principles, there are a few more guidelines that ease the testability of a codebase:</p>\n<p id=\"54e2\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">Make sure your code has seams:</strong>\u00a0From the definition on\u00a0<em class=\"markup--em markup--p-em\">Working Effectively with Legacy Code\u00a0</em>by<em class=\"markup--em markup--p-em\">\u00a0Michael Feathers,</em>\u00a0\u201c<em class=\"markup--em markup--p-em\">A seam is a place where you can alter behaviour in your program without editing that place</em>\u201d. Having seams is required in order to unit test code as you can replace behaviour with test doubles. Following the principles stated above will help with that as well as practising Test-Driven-Development, as unit tests can help with the design of your APIs.</p>\n<p id=\"4617\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">Don\u2019t mix object creation with application logic:\u00a0</strong>You should not carelessly create object instances. You should instead have two types of classes: application classes and factories. Application classes are those that do real work and have all the business logic while factories are used to create objects and respective dependencies. You should avoid using \u201cnew\u201d outside of factories, with the exception of the creation of data-objects (data structures or objects with only getters/setters), which you can create freely. If you create other classes in your application code, you won\u2019t be able to replace those with test doubles when unit testing (unless you use monkey-patching or bytecode-manipulation frameworks, but that leads to tests that are both difficult to create and maintain). If you have to create objects dynamically in your application code, you should use the\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://sourcemaking.com/design_patterns/abstract_factory\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://sourcemaking.com/design_patterns/abstract_factory\">Abstract Factory</a>\u00a0design pattern. That way, you can pass in a concrete factory as a dependency that implements that factory interface, and your application code can create objects without depending on a concrete implementation.</p>\n<p id=\"a698\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">Use Dependency Injection:</strong>\u00a0Related to the guideline above, you should provide the dependencies to your classes. A class should not be responsible for fetching its dependencies, either by creating them, using global state (e.g. Singletons) or getting dependencies through other dependencies (breaking the Law of Demeter). Preferably, dependencies should be provided to the class through its constructor. Take note that Dependency Injection is not a synonym of using a framework. It is something that can be perfectly done manually.</p>\n<p id=\"2630\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">Don\u2019t use global state:\u00a0</strong>Global state makes code more difficult to understand, as the user of those classes might not be aware of which variables need to be instantiated. It also makes tests more difficult to write due to the same reason and due to tests being able to influence each other, which is a potential source of flakiness. Also, be careful that\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/\" target=\"_blank\" rel=\"noopener nofollow noreferrer\" data-href=\"http://misko.hevery.com/code-reviewers-guide/flaw-brittle-global-state-singletons/\">Singletons are an example of global state</a>, and as such, should also be avoided in most cases. Please note that here \u201cSingleton\u201d is referring to the\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://sourcemaking.com/design_patterns/singleton\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://sourcemaking.com/design_patterns/singleton\">Singleton design pattern</a>, in which a class restricts its instantiation to only one instance. Classes that have a single instance without enforcing it, sometimes referred to as \u201csingletons\u201d without the capital \u201cS\u201d, are recommended instead. Dependency injection should be used to pass the instances to the objects that depend on them.</p>\n<p id=\"a2a1\" class=\"graf graf--p graf-after--p\"><strong class=\"markup--strong markup--p-strong\">Avoid static methods:</strong>\u00a0Static methods are procedural code and should be avoided in an object-oriented paradigm, as they don\u2019t provide the seams required for unit testing. Exceptions to this guideline are simple and pure methods, such as\u00a0<em class=\"markup--em markup--p-em\">Math.min()</em>. However, you might want to avoid the direct use of some other static methods, such as\u00a0<em class=\"markup--em markup--p-em\">System.currentTimeMillis(),\u00a0</em>as you won\u2019t be able to replace it with a test double. If you instead have a\u00a0<em class=\"markup--em markup--p-em\">TimestampSupplier</em>\u00a0interface or just\u00a0<em class=\"markup--em markup--p-em\">Supplier&lt;Long&gt;</em>, you can dependency-inject an implementation that uses\u00a0<em class=\"markup--em markup--p-em\">System.currentTimeMillis()</em>\u00a0in your production code and use a fake implementation in your test code, which might help you create better assertions in your tests.</p>\n<p id=\"9b19\" class=\"graf graf--p graf-after--p graf--trailing\"><strong class=\"markup--strong markup--p-strong\">Favour composition over inheritance:\u00a0</strong>You should prefer the usage of composition over inheritance. Composition allows your code to better follow the Single Responsibility Principle, makes the code more easy to test and avoids class number explosion. Composition provides more flexibility as the behaviour of the system is modelled by different interfaces that collaborate instead of creating a class hierarchy that distributes behaviour among business-domain classes via inheritance. It also makes the system more flexible as components can be assembled in different ways in runtime, without changing the code. There are some design patterns that help with this, such as the\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://sourcemaking.com/design_patterns/strategy\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://sourcemaking.com/design_patterns/strategy\">Strategy</a>\u00a0and\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://sourcemaking.com/design_patterns/decorator\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://sourcemaking.com/design_patterns/decorator\">Decorator</a>\u00a0patterns.</p>\n</div>\n</div>\n</section>\n<section class=\"section section--body\">\n<div class=\"section-divider\">\n<hr class=\"section-divider\" />\n</div>\n<div class=\"section-content\">\n<div class=\"section-inner sectionLayout--insetColumn\">\n<h3 id=\"9377\" class=\"graf graf--h3 graf--leading\">A small\u00a0example</h3>\n<p id=\"2208\" class=\"graf graf--p graf-after--h3\">Below is an example of code that is difficult to test, as it\u2019s highly coupled to multiple aspects of the system. This small code sample breaks most of the SOLID principles, the Law of Demeter and the above guidelines. In order to test it, you would have to use a bytecode-manipulating mocking framework (such as\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://github.com/powermock/powermock\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://github.com/powermock/powermock\">PowerMock</a>), which leads to tests that are difficult to write and maintain.</p>\n<pre><code data-enlighter-language=\"null\">// Difficult to test - coupled to the application, database and file system\r\npublic class MyClass {\r\n  \r\n  public void writeUserName(int id) {\r\n    String userName = App.getDatabaseManager().getUserDatabase().getUserName(id);\r\n    try (FileWriter writer = new FileWriter(\"user.txt\")) {\r\n      writer.write(userName);\r\n    }\r\n  }\r\n}</code></pre>\n<p id=\"3769\" class=\"graf graf--p graf-after--figure\">Now, here is another code sample, which although not perfect, is much easier to test. In this example, you can just provide a fake UserDatabase and a StringWriter instead of a FileWriter.</p>\n<pre><code data-enlighter-language=\"null\">// Easy to test - you can easily replace UserDatabase and Writer with test doubles\r\npublic class MyClass {\r\n  private final UserDatabase userDatabase;\r\n  \r\n  public MyClass(final UserDatabase userDatabase) {\r\n    this.userDatabase = userDatabase\r\n  }\r\n  \r\n  public void writeUserName(int id, Writer writer) {\r\n    final String userName = this.userDatabase.getUserName(id);\r\n    writer.write(userName);\r\n  }\r\n}</code></pre>\n<p id=\"592f\" class=\"graf graf--p graf--leading\">If you would like to learn more about these concepts, I really like and recommend\u00a0<a class=\"markup--anchor markup--p-anchor\" href=\"https://www.youtube.com/watch?v=acjvKJiOvXw\" target=\"_blank\" rel=\"nofollow noopener noreferrer\" data-href=\"https://www.youtube.com/watch?v=acjvKJiOvXw\">this video of a presentation by Mi\u0161ko Hevery</a>.</p>\n<p id=\"ff75\" class=\"graf graf--p graf-after--p\"><em class=\"markup--em markup--p-em\">Clean Code</em>\u00a0and\u00a0<em class=\"markup--em markup--p-em\">Clean Architecture</em>\u00a0are also two good books by Robert Martin that will teach you about the principles touched here and much more.</p>\n<p id=\"4608\" class=\"graf graf--p graf-after--p graf--trailing\">I hope that this post gave you some grounds about writing testable code and that by following these principles and guidelines you will be able to have a more clean, maintainable and testable codebase!</p>\n</div>\n<p>Source : <a href=\"https://medium.com/feedzaitech/writing-testable-code-b3201d4538eb\">https://medium.com/feedzaitech/writing-testable-code-b3201d4538eb</a></p>\n</div>\n</section>\n", "slug": "writing-testable-clean-code", "date": 1558182525, "cats": [13, 17, 16]}